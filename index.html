<html>
<head>
  <title>HarfBuzz Font Compare Tool</title>
  <style>
body {
  font-family: "Calibri";
  background-color: #c0e0c0;
}
table, th, td {
  border-collapse: collapse;
  border: 2px solid #c0d0c0;
  padding: 3px;
}
.label {
  text-align: right;
  font-weight: bold;
}
.svg {
  background-color: #f0f8f0;
  padding:6px;
}
.codes {
  font-family: 'Lucida Console';
  font-size: 70%;
}
.diff1 {
  background-color: #ef5;
}
.diff2 {
  background-color: #5ef;
}
input {
  background-color: #d0e0d0;
  accent-color: #608060;
}
input[type="range"] {
  background-color: #d0e0d0;
  accent-color: #586858;
  width: 35%;
}
button {
  background-color: #c0d0c0;
}
#text {
  font-size: 150%;
}
#script,#language {
  font-family: 'Lucida Console';
}
#shapeResult1,#shapeResult2 {
  font-family: 'Lucida Console';
  font-size: 80%;
}
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #ccc;
  color: #006080;
}
.tooltip .tooltiptext {
  visibility: hidden;
  position: absolute;
  width: 340px;
  background-color: #555;
  color: #fff;
  text-align: center;
  padding: 5px 0;
  border-radius: 6px;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.tooltip-bottom {
  top: 135%;
  left: 50%;
  margin-left: -60px;
}
.tooltip-bottom::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  margin-width: 5px;
  border-style: solid;
  border-color: transparent transparent #555 transparent;
}

#scrubber {
  width: 80%;
  margin: 0;
}
#cbHarfBuzzVersion {
  background-color: #f0f8f0;
}

  </style>
</head>
<meta charset="utf-8">
<h1>HarfBuzz Font Compare</h1>

<table border=1 width="100%">
  <tr hidden id='trNavigation'>
    <td class='label' width='10%'>Line:</td>
    <td>
      <input type='text' id='inputIndex'>
      <button id='btnGo' onclick='gotoLineIndex();'>Go</button>
      &nbsp;
      <button id="btnGotoLineFirst" onclick="gotoLineFirst();" accesskey='1'>First (Alt-1)</button>
      <button id="btnGotoLinePrev" onclick="gotoLineOfs(-1);" accesskey='2'>Prev (Alt-2)</button>
      <button id="btnGotoLineNext" onclick="gotoLineOfs(1);" accesskey='3'>Next (Alt-3)</button>
      <button id="btnGotoLineLast" onclick="gotoLineLast();" accesskey='4'>Last (Alt-4)</button>
    </td>
  </tr>
  <tr>
    <td class='label' width="10%">Text:</td>
    <td colspan=2 id='textdrop'>
      <input type="text" value="abc" id="text">
    </td>
  </tr>
  <tr>
    <td class='label' width="10%">Hex:</td>
    <td colspan=2>
      <input type="text" size="100" value="61 62 63" id="unicode">
    </td>
  </tr>
  <tr><td class='label' width="10%">Script/Lang/Dir:</td>
    <td colspan=2>
      <span class='tooltip'><input type="text" value="" id="script">
        <span class='tooltiptext tooltip-bottom' id='scriptList'>-</span>
      </span>,
      <span class='tooltip'><input type="text" value="" id="language">
        <span class='tooltiptext tooltip-bottom' id='languageList'>-</span>
      </span>
      <input type="radio" id="dirLTR"   name="direction" value="LTR" checked>
        <label for="dirLTR">LTR</label>
      <input type="radio" id="dirRTL"   name="direction" value="RTL">
        <label for="dirRTL">RTL</label>
    </td></tr>
  <tr><td class='label' width="10%">Features:</td>
    <td>
      <span class="tooltip">
        <input type="text" value="" id="features">
        <span id='featureList' class='tooltiptext tooltip-bottom'></span>
      </span>
      <font size=-1>e.g. '-liga,+jalt,+ss02'</font>
    </td></tr>

  <!--<tr><td>Font:</td><td><input type="text" value="" id="fontFile1"></td></tr>-->
  <tr><td class='label' >Font Drag & Drop:</td><td id='dropOne'>
      <button type="button" id="swapFonts" onclick="SwapFonts();">Swap #1 & #2</button>
    </td><td id='dropTwo'>
    <button type="button" id="resetFontTwo" onclick="ResetFontTwo();">Reset #2</button>
  </td></tr>
  <tr>
    <td class='label'>Font:</td>
    <td id='dropName1'><div id='fontName1'></div></td>
    <td id='dropName2'><div id='fontName2'></div></td>
  </tr>
  
  <tr hidden><td class='label' >Scale:</td>
    <td colspan=1>
      <input type="range" value="1000" min="100" max="4000" step="10" id="scale" ondblclick="scale.value=1000; updateResult();">
        <label for="scale" id="scaleLabel">1000</label>
    </td>
  </tr>

  <tr><td class='label' >Stretch/Offset:</td>
    <td><input type="range" value="0" min="0" max="500" id="stretch"></td>
    <td><input type="range" value="0" min="0" max="4000" id="offset2"></td>
  </tr>

  <tr><td class='label' >Color:</td>
  <td>
    <input type="radio" id="colourGlyph"   name="colour" value="glyph">
      <label for="colourGlyph">Glyph</label>
    <input type="radio" id="colourCluster" name="colour" value="cluster">
      <label for="colourCluster">Cluster</label>
    <input type="radio" id="colourSolid"   name="colour" value="solid" checked>
      <label for="colourSolid">Solid</label>
    <input type="text" id="solid1" value="#202080">
    </td>
    <td>
    <input type="radio" id="colourGlyph2"   name="colour2" value="glyph">
      <label for="colourGlyph2">Glyph</label>
    <input type="radio" id="colourCluster2" name="colour2" value="cluster">
      <label for="colourCluster2">Cluster</label>
    <input type="radio" id="colourSolid2"   name="colour2" value="solid" checked>
      <label for="colourSolid2">Solid</label>
    <input type="text" id="solid2" value="#f37418">
    </td>
  </tr>
  <tr><td class='label'>Opacity Fill:</td>
    <td>
      <input type="range" value="0.7" min="0" max="1.0" step="0.01" id="opacityFill">
    </td>
    <td>
      <input type="range" value="0.3" min="0" max="1.0" step="0.01" id="opacityFill2">
    </td>
  </tr>
  <tr><td class='label'>Opacity Stroke:</td>
    <td>
      <input type="range" value="0.0" min="0" max="1.0" step="0.01" id="opacityStroke">
    </td>
    <td>
      <input type="range" value="0.0" min="0" max="1.0" step="0.01" id="opacityStroke2">
    </td>
  </tr>
  <tr><td class='label'>Stroke Width:</td>
    <td>
      <input type="range" value="7" min="1" max="51" step="1" id="strokeWidth">
    </td>
    <td>
      <input type="range" value="7" min="1" max="51" step="1" id="strokeWidth2">
    </td>
  </tr>
  <tr>
    <td class='label'>Options:</td>
    <td>
      <input type="checkbox" id="showGids"><label for="showGids">GIDs</label>
      <input type="checkbox" id="showGidNames"><label for="showGids">Names</label>
      <input type="checkbox" id="cbDifference" checked disabled><label for="cbDifference">Difference</label>
      <input type="checkbox" id="baseLine"><label for="baseLine">Baseline</label>
      <input type="checkbox" id="showBoundingBox"><label for="showBoundingBox">Bounding Box</label>
      <input type="checkbox" id="showOrigin"><label for="showOrigin">Origins</label>
      <input type="checkbox" id="onlyGSUB"><label for="onlyGSUB">GSUB Only</label>
      <!--<input type="checkbox" id="exclusion"><label for="exclusion">Exclusion</label>-->
      <!--<input type="checkbox" id="showBbox"><label for="showBbox">Bounds</label>-->
    </td>
    <td></td>
  </tr>
<!--<p>Colour: <input type="checkbox" id="colourEnabled" checked></p>-->

<tr><td class='svg' colspan=3>
<!--<a id="svgResult" href="#" title="Click to download"></a>-->
<div class='svg' id='svgResult'></div>
<p><button id="saveSvg" onclick="DownloadSvg();">Download SVG</button>
  <button id="zoomOutSVG" onclick="zoomSVG(-1);">-</button>
  <button id="zoomResetSVG" onclick="zoomSVG(0);" title="Middle click or Shift-Left and drag to pan the SVG">100%</button>
  <button id="zoomInSVG" onclick="zoomSVG(1);">+</button>
  <font size=-1>&nbsp; Shift-Scroll to zoom. Left-Mouse to drag.</span>
</td></tr>
<tr>
  <td class='label'>Timeline:</td>
  <td colspan=2>
    <input type="range" id='scrubber' name='scrubber' min=0 max=242 value=0/>
    <button id='tlPrev' onclick="timeLinePrev();">&lt;</button>
    <button id='tlGsubEnd' onclick="timeLineGsubEnd();">|</button>
    <button id='tlNext' onclick="timeLineNext();">&gt;</button>
    <span id='scrubber_count'></span>
    </br><span class='codes' id='scrubber_text'></span>
</td></tr>
<tr>
  <td class='label' width='10%'>HarfBuzz:</td>
  <td width='45%'><div id='harfBuzzResult1'></div><button type="button" id="copyHB1" onclick="copyTraceToClipboard(hbsvg1);">Copy Trace #1</button></td>
  <td width='45%'><div id='harfBuzzResult2'></div><button type="button" id="copyHB1" onclick="copyTraceToClipboard(hbsvg2);">Copy Trace #2</button></td>
</tr>
<tr>
  <td class='label' width="10%">Result:</td>
  <td width='45%'><div id='shapeResult1'></div></td>
  <td width='45%'><div id='shapeResult2'></div></td>
</tr>
</table>
<!--
<p>Debug1:<div id="debugResult"></div></p>
<p>Debug2:<div id="debugResult2"></div></p>
<p>Debug3:<div id="debugResult3"></div></p>
--->

<script type="text/javascript" src="./js/hbjs-12.3.0/hb.js"></script> <!-- Module - REQUIRED -->
<script type="text/javascript" src="./js/hbjs.js"></script> <!-- Wrapper, can be used without -->
<script high>

</script>

<script type="text/javascript" src="./js/otinfo.min.js"></script>
<script type="module" src="./js/opentype.min.mjs" async></script>
<script type="module" src="./js/opentype.layout.gdef.mjs" async></script>
<script type="module" async defer>
'use strict';

import * as opentype from './js/opentype.min.mjs';
import Layout from './js/opentype.layout.gdef.mjs';
import {CPaths64, GlyphCompareClass} from './js/glyphcompare.mjs';
window.opentype = opentype;
window.Layout = Layout;


const hbVersions = [];
window.hbVersions = hbVersions;

function applyHarfBuzz(hbNew) {
  setHarfBuzz(hbNew);
  updateResult();
}

async function loadHarfBuzzVersion(version) {
  let promise = new Promise((resolve, reject) => {
    if (hbVersions[version]) {
      applyHarfBuzz(hb);
      resolve(hbVersions[version]);
    }
    const scriptSource = `./js/hbjs-${version}/hb.js`;
    const newScriptElement = document.createElement('script');
    newScriptElement.onload = function() {
      createHarfBuzz().then(hbmodule=>{
        loadedHarfBuzzModule(hbmodule);
        applyHarfBuzz(hbVersions[version]);
        resolve(hbVersions[version]);
      });
    }
    newScriptElement.onerror = function() {
      window.alert(`Could not load HarfBuzz ${version}`);
    }
    newScriptElement.src = scriptSource;
    document.head.appendChild(newScriptElement);    
  });
  return await promise;
}

function loadedHarfBuzzModule(module) {
  const hb = hbjs(module);
  window.hb = hb;
  window.harfBuzzModule = module;
  const version = hb.version_string();
  //~~//console.log('loadedHarfBuzzModule', version, hb); //~~
  hbVersions[version] = hb;
  return hb;
}

// Dynamically load `hb.js` and `hb.wasm` based on query string `?hb=11.0.1`
const params = new URL(document.location.toString()).searchParams;
let hb_version = params.get('hb');
if (hb_version) {
  const hbv_validate = /^\d\d\.\d\.\d$/g;
  if (hb_version.match(hbv_validate)) {
    //??//loadHarfBuzzVersion(hb_version);
  } else {
    window.alert(`Illegal version\r\n"${hb_version}"`);
  }  
}

const promises = [
      createHarfBuzz()
    ];

let harfBuzzModule;
var hb;
var hbBrowserMode = false;

Promise.all(promises).then(([aharfBuzzModule]) => {
  harfBuzzModule = aharfBuzzModule;
  hb = hbjs(harfBuzzModule);
  window.hb = hb;
  hbVersions[hb.version_string()] = hb;
  onResourcesLoaded();
});

var hb_stop_at = '';
var hb_stop_phase = null;


function isExists(v) {
  if ((typeof(v) === 'object') && (v === null)) return false;
  return typeof(v) !== 'undefined';
}

//----------------------------------
// Matt Page / MattMatic
// 2024
//----------------------------------

// Used for colouration of glyphs or clusters
const glyphColors = ['#bb87e3','#bc6b0e','#57118c','#64902e','#91bbec','#d65e02','#1d5799','#984c11','#271909'];
var textLineInfo = null;
var textLineFileName = '';

//------------------------------
// Drag and drop utilities
//------------------------------
function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);

//----------------------------------
// HarfBuzz SVG Class
//----------------------------------
class hbSvgClass {
  constructor(hb) {
    this.options = {};
    this.results = {};
    this.hb = hb;
  }
  setHarfBuzz(hb) {
    const fbOld = this.fontBlob;
    this.freeFont();
    this.hb = hb;
    if (hb) this.hbVersion = hb.version_string();
    if (fbOld) this.setFontBlob(fbOld);
  }
  destroy() {
    this.freeFont();
    delete(this.fontBlob);
  }
  freeFontBlob() {
    this.freeFont();
    this.fileDescription = null;
    delete(this.fontBlob);
  }
  freeFont() {
    this.results = {};
    if (this.font) { this.font.destroy(); delete(this.font); }
    if (this.face) { this.face.destroy(); delete(this.face); }
    if (this.blob) { this.blob.destroy(); delete(this.blob); }
    delete(this.otLayout);
    delete(this.otFont);
    if (this.gc) this.gc.destroy();
    delete this.gc;
  }
  doGtable(t) {
    if (!t) return;
    if (t.scriptTable) {
      for (const key in t.scriptTable) {
        this.fontInfo.scripts.add(key);
        for (const val of t.scriptTable[key]) {
          this.fontInfo.languages.add(val);
        }
      }
    }
    if (t.featureListTable) {
      for (const val of t.featureListTable) {
        this.fontInfo.features.add(val);
      }
    }
  }
  fillTables() {
    this.fontInfo.scripts = new Set();
    this.fontInfo.languages = new Set();
    this.fontInfo.features = new Set();
    this.doGtable(this.fontInfo.GSUB);
    this.doGtable(this.fontInfo.GPOS);
  }
  setFontBlob(fb) {
    this.freeFont();
    this.fontBlob = fb;
    this.fontInfo = null;
    if (fb) {
      const otInfo = OTInfo.parse(fb);
      this.fontInfo = otInfo[0];
      const fontName = this.fontInfo.name;
      //console.log(fontName);
      this.fileDescription = fontName.fullName + '</br>' + fontName.version;
      this.fillTables();
    } else {
      this.fileDescription = '';
    }
    if (!fb) return;
    this.blob = this.hb.createBlob(this.fontBlob);
    this.face = this.hb.createFace(this.blob, 0);
    this.font = this.hb.createFont(this.face);
    const debgTable = this.face.reference_table("Debg");
    if (debgTable) {
      this.debugInfo = JSON.parse(new TextDecoder("utf8").decode(debgTable));
      this.debugInfo = this.debugInfo["com.github.fonttools.feaLib"];
    } else {
      this.debugInfo = null;
    }
    this.otFont = opentype.parse(this.fontBlob);
    this.otLayout = new Layout(this.otFont, 'GPOS');

    this.gc = new GlyphCompareClass(this.hb);
    this.gc.setFontBlob(this.fontBlob);
    this.gc.setScriptLanguage(this?.options.script, this?.options.lang);
  }
  setScriptLanguage(script, lang) {
    this.options.script = script;
    this.options.lang = lang;
    if (this.gc)
      this.gc.setScriptLanguage(this.options.script, this.options.lang);
  }
  getDebugInfo(ix/*: number*/, stage/*: string*/) {
    if (this.debugInfo && this.debugInfo[stage] && this.debugInfo[stage][ix]) {
      const debugData = this.debugInfo[stage][ix];
      return {
        source: debugData[0],
        name: debugData[1],
        script: debugData[2] && debugData[2][0],
        language: debugData[2] && debugData[2][1],
        feature: debugData[2] && debugData[2][2],
      };
    }
    return null;
  }
  getGlyphClass(gid) {
    return this.otLayout.getGlyphClass(this.otFont?.tables?.gdef?.classDef, gid);
  }
  getGlyphName(gid) {
    const glyphData = this.otFont?.glyphs?.get(gid);
    if (!glyphData) return undefined;
    return glyphData.name;
  }
  isGlyphClassMark(gid) {
    return (this.getGlyphClass(gid) === 3);
  }
  copyOptions(fromOptions) {
    this.options = structuredClone(fromOptions);
  }
  toSvg(text, doTimeline, doUpdateScrubInfo) {
    return hbToSvg(this, text, this.options, doTimeline, doUpdateScrubInfo);
  }
  swapWith(other) {
    let b1 = this.fontBlob;
    let b2 = other.fontBlob;
    this.setFontBlob(b2);
    other.setFontBlob(b1);
  }
}

var hbsvg1 = new hbSvgClass();
var hbsvg2 = new hbSvgClass();

function SwapFonts() {
  hbsvg1.swapWith(hbsvg2);
  updateResult();
  updateLists();
}

function ResetFontTwo() {
  hbsvg2.freeFontBlob();
  updateResult();
}

function formatJson(json) {
  return JSON.stringify(json).replace('[', '[\r\n').replace(/},/g, '},\r\n');
}

function DownloadSvg() {
  let tempLink = document.createElement("a");
  let taBlob = new Blob([svgResult.innerHTML.replace(' height="512"', '')], { type: 'text/plain' });
  tempLink.setAttribute('href', URL.createObjectURL(taBlob));
  tempLink.setAttribute('download', text.value + '.svg');
  tempLink.click();
  URL.revokeObjectURL(tempLink.href);
}

function hideTextButtons(dohide) {
  //btnGotoLineFirst.hidden = dohide;
  //btnGotoLinePrev.hidden = dohide;
  //btnGotoLineNext.hidden = dohide;
  //btnGotoLineLast.hidden = dohide;
  trNavigation.hidden = dohide;
}

var lineNo = 0;
var mya = [];

function LoadLine() {
  if (lineNo < 0) lineNo = 0;
  if (lineNo >= mya.length) lineNo = mya.length - 1;
  while ((lineNo > 0) && !mya[lineNo]) lineNo--;
  while ((lineNo < mya.length) && !mya[lineNo]) lineNo++;
  inputIndex.value = (lineNo + 1);
  if (mya[lineNo]) {
    text.value = mya[lineNo];
    textLineInfo = '#'+(lineNo+1)+"/"+mya.length+ ' ('+textLineFileName+')';
    UpdateText();
  }
}

function gotoLineFirst() {
  lineNo = 0;
  LoadLine();
}

function gotoLineOfs(ofs) {
  lineNo += ofs;
  LoadLine();
}

function gotoLineLast() {
  lineNo = mya.length - 1;
  LoadLine();
}

function gotoLineIndex() {
  lineNo = parseInt(inputIndex.value) - 1;
  LoadLine();
}

function updateTextLines(textLines) {
  mya = textLines.split(/\r?\n+/g);
  mya = mya.flat();
}

function iterateGtable(gtable, theKey, outputset) {
  if (!gtable) return;
  const scriptTable = gtable.scriptTable;
  if (!scriptTable) return;
  if (!scriptTable[theKey]) return;
  for (const y of scriptTable[theKey]) {
    outputset.add(y);
  }
}

function updateLists() {
  // Update script, language, and feature lists from this.fontInfo
  const fontInfo = hbsvg1.fontInfo;
  scriptList.innerText = '(empty)';
  languageList.innerText = '(empty)';
  featureList.innerHTML = '(empty)';
  if (!fontInfo) {
    return;
  }
  //console.log(fontInfo);
  //console.log(fontInfo.scripts, fontInfo.languages, fontInfo.features);
  if (fontInfo.scripts.size > 0) {
    scriptList.innerText = '"'+[...fontInfo.scripts].sort().join('", "')+'"';
  }
  let languages = fontInfo.languages;

  if (script.value !== '') {
    let theScript = script.value.toLowerCase();
    languages = new Set();
    iterateGtable(fontInfo.GSUB, theScript, languages);
    iterateGtable(fontInfo.GPOS, theScript, languages);
  }
  if (languages.size > 0) {
    languageList.innerText = '"'+[...languages].sort().join('", "')+'"';
  }
  if (fontInfo.features.size > 0) {
    featureList.innerHTML = [...fontInfo.features].sort().join(", ");
  }
}

function getHarfBuzzResult(hbsvg) {
  let txt = ''
  if (hbsvg.trace.limits.maxGlyphAbort) txt += "<font color='red'>!GLYPH COUNT! "+hbsvg.trace.limits.maxGlyph+"</font></br>\r\n";
  if (hbsvg.trace.limits.maxDepthAbort) txt += "<font color='red'>!GSUB/GPOS DEPTH!</font></br>\r\n" + txt;
  if (hbsvg.trace && hbsvg.trace.limits) {
    txt += 'GSUB/GPOS Depth: '+hbsvg.trace.limits.maxDepth + '</br>\r\n';
  }
  return txt;
}

function getTraceJSON(hbsvg) {
  let txt = '';
  txt += '{"font":"'+hbsvg.fileDescription+'",\r\n'+
         ' "text":"'+text.value+'",\r\n'+
         ' "script":"'+script.value+'",\r\n'+
         ' "language":"'+language.value+'",\r\n'+
         ' "features":"'+features.value+'",\r\n'+
         ' "count":' + hbsvg.trace.count+',\r\n';
  if (hbsvg.trace.gsub_point > 0)
        txt += ' "gsub_start:":' + hbsvg.trace.gsub_point+',\r\n';
  if (hbsvg.trace.gpos_point > 0)
        txt += ' "gpos_start:":' + hbsvg.trace.gpos_point+',\r\n';
  if (scrubber.value > 0) {
    txt += ' "stop_at":'+scrubber.value+',\r\n';
  }
  txt += ' "dir":"';
  if (dirRTL.checked) txt += 'RTL'; else txt += 'LTR';
  txt += '"},\r\n';
  txt += '[\r\n';
  for (let o of hbsvg.trace) {
    txt += (" ".repeat(o.d || 0)) + JSON.stringify(o)+',\r\n';
  }
  txt += ']';
  return txt;
}

function copyTraceToClipboard(hbsvg) {
  navigator.clipboard.writeText(getTraceJSON(hbsvg));
}

function getShapeResult(hbsvg) {
  let json = formatJson(hbsvg.results.json || '');
  if (hbsvg.options.showGidNames) {
    // Iterate and change the `"g":###,` -> `"g":"NAME",`
    json = json.replaceAll(/"g":\d+,/gi, function(txt) {
      const gid = txt.match(/\d+/);
      const name = hbsvg.getGlyphName(Number(gid));
      //console.log(txt, gid, name);
      if (name) {
        if (hbsvg.options.showGids)
          return `"g":"${gid}:${name}",`;
        else
          return `"g":"${name}",`;
      } else {
        return `"g":${gid},`;
      }
    });
  }
  return json;
}

function getShapeResultDiff(jsonThis, jsonPrev, spanStyle) {
  if (!jsonPrev || (jsonPrev === '')) return jsonThis;
  if (!jsonThis || (jsonThis === '')) return jsonThis;
  const linesThis = jsonThis.split('\r\n');
  const linesPrev = jsonPrev.split('\r\n');
  let res = '';
  const size = linesThis.length;
  for (let i=0; i<size; i++) {
    const lineThis = linesThis[i];
    const linePrev = linesPrev[i];
    if ((lineThis !== linePrev) && lineThis && linePrev && (lineThis !== '') && (linePrev !== '')) {
      const valsThis = linesThis[i].split(',"');
      const valsPrev = linesPrev[i].split(',"');
      let l = '';
      const n = valsThis.length;
      for (let ii=0; ii<n; ii++) {
        let vThis = valsThis[ii];
        let vPrev = valsPrev[ii];
        if (vThis !== vPrev) {
          if (vThis.startsWith('{')) {
            l += '{';
            vThis = vThis.substr(1);
          }
          if (l.endsWith('"')) {
            l = l.slice(0, -1);
            vThis = '"' + vThis;
          }
          l += '<span class="'+spanStyle+'">'+vThis+'</span>';
        }
        else
          l += vThis;
        if (ii < (n-1)) l += ',"';
      }
      res += l;
    } else {
      res += linesThis[i];
    }
    res += '\r\n';
  }
  return res;
}

function updateSvg(dive, html) {
  let oldScale = 1;
  let oldTranslate = {x:0, y:0};

  let svge = dive.children[0];
  if (typeof svge !== 'undefined') {
    oldScale = svge.currentScale;
    oldTranslate = svge.currentTranslate;
  }
  dive.innerHTML = html;
  svge = dive.children[0];
  svge.currentScale = oldScale;
  svge.currentTranslate.x = oldTranslate.x;
  svge.currentTranslate.y = oldTranslate.y;
}

function adjustSVGzoom(svge, amount) {
  let newScale
  if (amount < 0){newScale=svge.currentScale/1.1}
  if (amount > 0){newScale=svge.currentScale*1.1}
  if (amount ==0){newScale=1}
  let oldScale=svge.currentScale
  let y = svge.clientHeight / 2;
  svge.currentTranslate.y=(-y+svge.currentTranslate.y)*(newScale/oldScale)
  svge.currentTranslate.x=(0+svge.currentTranslate.x)*(newScale/oldScale)
  svge.currentScale=newScale
  svge.currentTranslate.y+=y;
  svge.currentTranslate.x+=0;
}

function zoomSVG(amount) {
  const svge = svgResult.children[0];
  adjustSVGzoom(svge, amount);
  if (amount==0) {
    svge.currentTranslate.y = 0;
    svge.currentTranslate.x = 0;
  }
}

function addSVGZoomAndPan(svg){
  // From https://github.com/Holger-Will/SVGZoomAndPan/blob/master/zap.js
  svg.addEventListener("wheel",function(evt){
    if (evt.shiftKey) {
      // Only zoom while the shift key is pressed (to allow scrolling the page)
      let newScale
      if(evt.deltaY>0){newScale=svg.currentScale/1.1}
      if(evt.deltaY<0){newScale=svg.currentScale*1.1}
      let oldScale=svg.currentScale
       svg.currentTranslate.x=(-evt.offsetX+svg.currentTranslate.x)*(newScale/oldScale)
       svg.currentTranslate.y=(-evt.offsetY+svg.currentTranslate.y)*(newScale/oldScale)
       svg.currentScale=newScale
       svg.currentTranslate.x+=evt.offsetX
       svg.currentTranslate.y+=evt.offsetY
       let event = new Event('SVGZoom');
       svg.dispatchEvent(event);
       evt.preventDefault();  // Stop window from scrolling (update to zap.js)
     }
  })
  svg.addEventListener("mousedown",function(evt){
    if(!evt.shiftKey || evt.button==1){
      svg.classList.add("dragging")
      let ox=evt.offsetX
      let oy=evt.offsetY
      let otx=svg.currentTranslate.x
      let oty=svg.currentTranslate.y
      svg.addEventListener("mousemove",move)
      document.addEventListener("mouseup",out)
      let event = new Event('SVGScroll');
      svg.dispatchEvent(event)
      function out(evt){
        svg.removeEventListener("mousemove",move)
        document.removeEventListener("mouseup",out)
        svg.classList.remove("dragging")
        let event = new Event('SVGScroll');
        svg.dispatchEvent(event)
      }
      function move(evt){
        svg.currentTranslate.x=otx+(evt.offsetX-ox)
        svg.currentTranslate.y=oty+(evt.offsetY-oy)
        let event = new Event('SVGScroll');
        svg.dispatchEvent(event)
      }
    }
  })
}

class pathToSvg {
  constructor() {
    this.svgData = '';
  }
  genSVGPath(p64, settings) {
    const size = p64.size();
    for (let i=0;i<size;i++) {
      const point = p64.get(i);
      const x= Number(point.x) *  1;
      const y= Number(point.y) * -1;
      if (i==0)
        this.svgData += `M${x},${y}`;
      else
        this.svgData += `L${x},${y}`;
      point.delete(); //??
    }
    this.svgData += 'z';
  }
  genSVGPaths(ps64, settings) {
    if (!ps64) return;
    settings = settings || {};
    if (!isExists(settings.mixBlendMode)) settings.mixBlendMode = 'normal';
    this.svgData += '<path ';
    if (settings.id) {
      this.svgData += `id="${settings.id}" `;
    }
    this.svgData += ' style="';
    if (isExists(settings.fillColor)) {
      if (!isExists(settings.fillOpacity)) settings.fillOpacity = 0.5;
      this.svgData += 'fill:'+settings.fillColor
                    +';fill-opacity:'+settings.fillOpacity
    } else {
      this.svgData += ';fill-opacity:0';
    }
    if (isExists(settings.strokeColor)) {
      if (!isExists(settings.strokeOpacity)) settings.strokeOpacity = 1.0;
      if (!isExists(settings.strokeWidth)) settings.strokeWidth = 2;
      this.svgData += ';stroke:'+settings.strokeColor
                    +';stroke-opacity:'+settings.strokeOpacity
                    +';stroke-width:'+settings.strokeWidth
                    +';stroke-linejoin=\'round\''
    }
    if (settings.mixBlendMode !== 'normal')
      this.svgData +=';mix-blend-mode:\''+settings.mixBlendMode+'\''
    
    this.svgData += '" d="';
    const size = ps64.size();
    for (let i=0;i<size;i++) {
      const path = ps64.get(i);
      this.genSVGPath(path, settings);
      path.delete();
    }
    this.svgData += '"/>\r\n';
    return this.svgData;
  }
}


function updateControls() {
  cbDifference.disabled = !((hbsvg1.gc) && (hbsvg2.gc));  
}

function updateResult() {
  scaleLabel.innerText = scale.value;

  let svgPath = '';
  const txt = text.value;

  /*
  if (exclusion.checked) {
    svgPath += '<path d="M-250 -1800 l0 3000 l8000 0 l0 -3000 z" fill="#c0c0c0"/>'
  }
  */
  if (baseLine.checked) {
    svgPath +=
      '<path style="stroke:#ff4040;stroke-opacity:0.5;stroke-width:5" d="M-300 0 L16000 0"></path>'+
      '<path style="stroke:#ff4040;stroke-opacity:0.5;stroke-width:5" d="M0 -1500 L0 3000"></path>';
  }

  if (script.value !== '') {
    hbsvg2.options.script = script.value;
    hbsvg2.options.language = language.value;
    if (dirLTR.checked)
      hbsvg2.options.direction = 'ltr';
    else
      hbsvg2.options.direction = 'rtl';
  } else {
    hbsvg2.options.script = '';
    hbsvg2.options.language = '';
    hbsvg2.options.direction = '';
  }
  hbsvg2.options.featureString = features.value;
  hbsvg2.options.scale = scale.value;
  hbsvg2.options.x_stretch = parseInt(stretch.value, 10);
  hbsvg2.options.x = parseInt(offset2.value, 10);

  hbsvg2.options.colour_solid = solid2.value;// '#f37418';
  hbsvg2.options.colour_mode = 0;
  hbsvg2.options.opacity_fill = opacityFill2.value;
  hbsvg2.options.opacity_stroke = opacityStroke2.value;
  hbsvg2.options.stroke_width = strokeWidth2.value;
  hbsvg2.options.colour_mode = 0;
  if (colourGlyph2.checked) hbsvg2.options.colour_mode= 1;
  if (colourCluster2.checked) hbsvg2.options.colour_mode = 2;

  hbsvg1.copyOptions(hbsvg2.options);
  hbsvg1.options.x = 0;
  hbsvg1.options.colour_solid = solid1.value; //'#1685f3';
  hbsvg1.options.colour_mode = 0;
  /*
  if (exclusion.checked) {
    hbsvg1.options.blendMode = 'multiply';
  }
  */
  hbsvg1.options.showGids = showGids.checked;
  hbsvg1.options.showGidNames = showGidNames.checked;
  hbsvg2.options.showGids = showGids.checked;
  hbsvg2.options.showGidNames = showGidNames.checked;
  if (colourGlyph.checked) hbsvg1.options.colour_mode= 1;
  if (colourCluster.checked) hbsvg1.options.colour_mode = 2;

  hbsvg1.options.opacity_fill = opacityFill.value;
  hbsvg1.options.opacity_stroke = opacityStroke.value;
  hbsvg1.options.stroke_width = strokeWidth.value;

  let svg1 = '';
  let svg2 = '';
  if (hbsvg2.fontBlob) svg2 = hbsvg2.toSvg(txt, true, false);
  if (hbsvg1.fontBlob) svg1 = hbsvg1.toSvg(txt, true, true);

  if (hbsvg1.gc && hbsvg2.gc && !cbDifference.disabled && cbDifference.checked) {
    // Render a difference highlight
    let featureString = features.value || '';
    if (featureString && featureString.length > 0) {
      featureString = `+DUMY,${featureString},`; // Copied from Crowbar... "SERIOUSLY?"
    }
    //let json1 = hbsvg1.gc.shape(txt, featureString);
    //let json2 = hbsvg2.gc.shape(txt, featureString);
    const json1 = hbsvg1.results.json; // Take the already calculated ones that include the timeline
    const json2 = hbsvg2.results.json;
    let p1 = hbsvg1.gc.toPath(json1, {stretch:hbsvg2.options.x_stretch});
    let p2 = hbsvg2.gc.toPath(json2, {stretch:hbsvg2.options.x_stretch});
    let po = hbsvg1.gc.overlapToCPaths64(hbsvg2.gc);
    let p2svg = new pathToSvg();
    svgPath += p2svg.genSVGPaths(po.paths64, {strokeColor:'#2f4', strokeWidth:151, strokeOpacity:0.7, fillColor:'#2f4', fillOpacity:0.1});
    po.destroy();
    p2.destroy();
    p1.destroy();
  }

  if (hbsvg2.fontBlob) {
    svgPath += svg2;
    harfBuzzResult2.innerHTML = getHarfBuzzResult(hbsvg2);
  } else {
    harfBuzzResult2.innerHTML = '';
  }
  if (hbsvg1.fontBlob) {
    svgPath += svg1;
    harfBuzzResult1.innerHTML = getHarfBuzzResult(hbsvg1);
  } else {
    harfBuzzResult1.innerHTML = '';
  }

  let hbsgv1_json = getShapeResult(hbsvg1);
  let hbsgv2_json = getShapeResult(hbsvg2);
  if (hbsvg2.fontBlob) {
    shapeResult2.innerHTML = getShapeResultDiff(hbsgv2_json, hbsgv1_json, 'diff2');
  } else {
    shapeResult2.innerHTML = '';    
  }
  if (hbsvg1.fontBlob) {
    shapeResult1.innerHTML = getShapeResultDiff(hbsgv1_json, hbsgv2_json, 'diff1');
  } else {
    shapeResult1.innerHTML = '';
  }
  fontName1.innerHTML = hbsvg1.fileDescription || '';
  fontName2.innerHTML = hbsvg2.fileDescription || '';

  if (hbsvg1.getGlyphName(0) || hbsvg2.getGlyphName(0)) {
    showGidNames.disabled = false;
  } else {
    showGidNames.disabled = true;
  }


  // NOTE: Origin 0,0 is top left.
  let xmin = -250;    // Space to the LEFT
  let ymin = -1800;   // Space ABOVE
  let height = 3000;
  let heightOut = 400;
  let width = (window.innerWidth) * height / heightOut * 0.95;

  let bbox = xmin + ' ' + ymin + ' ' + width + ' ' + height;

  let ih = '<svg xmlns="http://www.w3.org/2000/svg"'
    +' height="'+heightOut+'"'
    +' viewBox="' + bbox + '"'
    +'>';
  if (textLineInfo) {
    ih += '<text font-size="120" x="0" y="1200" fill="green">'+textLineInfo+'</text>';
  }
  ih += svgPath + '</svg>';
  updateSvg(svgResult, ih);
  let svge = svgResult.children[0];
  addSVGZoomAndPan(svge);
  //debugResult.innerText = 'upem='+hbsvg1.face.upem;
}

function onResourcesLoaded() {
  //document.getElementById('hbversion').innerHTML = hb.version_string()
  let fontname = 'samples/Gulzar-Regular-1.002.ttf';
  fetch(fontname).then(function (res) {
    return res.arrayBuffer();
  }).then(function (blob) { // can be used without our wrapper
    window.fontBlob = new Uint8Array(blob);
    hbsvg1.setHarfBuzz(hb);
    hbsvg2.setHarfBuzz(hb);
    hbsvg1.setFontBlob(window.fontBlob);
    hbsvg2.freeFontBlob();
    acquireFontAndLists(window.opener);
    updateResult();
    updateLists();
    populateHarfBuzzVersionChoice();
  });
}

/*
let harfBuzzModule; // not really needed with the hbjs wrapper
createHarfBuzz().then(hbmodule=>{
  harfBuzzModule = hbmodule;
  window.hb = hbjs(hbmodule);
  hbversion.innerHTML=hb.version_string()
  onResourcesLoaded();
});
*/

function UpdateListener(id, event, foo) {
  let e = document.getElementById(id);
  if (e && !foo) {
    e.addEventListener(event, function(e) {
      updateResult();
      updateLists();
    });
  } else
  if (e) {
    e.addEventListener(event, function(e) {
      foo(e);
    });
  }
}

function handleGidNamesChanged() {
  if (showGidNames.checked) {
    //showGids.checked = true;
  }
  updateResult();
  updateLists();
}

/*
document.addEventListener('dragover', function (e) {
  e.stopPropagation(); e.preventDefault();
}, false);
document.addEventListener('dragleave', function (e) {
  e.stopPropagation(); e.preventDefault();
}, false);
document.addEventListener('drop', function (e) {
  e.stopPropagation(); e.preventDefault();
  //ef.value = e.dataTransfer.files[0];
  handleFontUpdate(e.dataTransfer.files[0]);
});
*/


function handleFontUpdate(file, which) {
  if (!file) return;
  let reader = new FileReader();
  reader.addEventListener("load", function () {
    window.fontBlob = new Uint8Array(reader.result);
    if (!which) {
      if (fontOne.checked)
        hbsvg1.setFontBlob(window.fontBlob);
      else
        hbsvg2.setFontBlob(window.fontBlob);
    } else {
      which.setFontBlob(window.fontBlob);
    }
    updateControls();
    updateResult();
    updateLists();
  });
  let fdate = new Date(file.lastModified);
  reader.readAsArrayBuffer(file);
}

function handleTextDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  console.log(fileName);
  textLineFileName = fileName;
  if (!fileName.endsWith('.txt')) return;
  let reader = new FileReader();
  reader.onload = function(e) {
    updateTextLines(reader.result);
    hideTextButtons(false);
    gotoLineFirst();
  }
  reader.readAsText(file);
}

function handleFontUpdate1(file) { handleFontUpdate(file, hbsvg1); }
function handleFontUpdate2(file) { handleFontUpdate(file, hbsvg2); }

patchDragDrop(document.getElementById('dropOne'), handleFontUpdate1);
patchDragDrop(document.getElementById('dropName1'), handleFontUpdate1);
patchDragDrop(document.getElementById('dropTwo'), handleFontUpdate2);
patchDragDrop(document.getElementById('dropName2'), handleFontUpdate2);
patchDragDrop(document.getElementById('textdrop'), handleTextDrop);

// Operate on results of font.pathToJson(gid)
// extxy - gets filled with the maximum extents .x and .y of the glyph
//         so can be used for advance in the GSUB stage (where there's no metrics yet available)
function glyphToRelative(glyph, retxy, extxy) {
  let r = [];
  let x = 0;
  let y = 0;
  let last_x, last_y;
  let ext = {xl:null, yl:null, xh:null, yh:null};
  let res = glyph.reduce( (acc,w) => {
    let v = {};
    v.type = w.type.toLowerCase();
    v.values = w.values.map( function(z, i) {
      if (i%2)
      {
        last_y = z;
        return -(z - y);
      } else
      {
        last_x = z;
        return z - x;
      }
      });
    x = last_x;
    y = last_y;
    if ((ext.xh === null) || (x>ext.xh)) ext.xh = x;
    if ((ext.yh === null) || (y>ext.yh)) ext.yh = y;
    if ((ext.xl === null) || (x<ext.xl)) ext.xl = x;
    if ((ext.yl === null) || (y<ext.yl)) ext.yl = y;
    return acc.concat(v);
  }, []);
  // Go back to relative origin...
  if (retxy) {
    let v = {}
    v.type = 'm';
    v.values = [-x, y];
    res.push(v);
  }
  if (extxy) {
    extxy.xh = ext.xh;
    extxy.yh = ext.yh;
    extxy.xl = ext.xl;
    extxy.yl = ext.yl;
    if (extxy.xh === null) extxy.xh = 0;
    if (extxy.yh === null) extxy.yh = 0;
    if (extxy.xl === null) extxy.xl = 0;
    if (extxy.yl === null) extxy.yl = 0;
    extxy.w = (ext.xh - ext.xl)
    extxy.h = (ext.yh - ext.yl)
  }
  return res;
}

function jsonToSvg(pathArray) {
  let res = pathArray.reduce( (acc, gl) => {
    let v = gl.type + gl.values.join(' ');
    return acc.concat(v);
  }, '');
  return res;
}

function generateHtmlForTrace(trace, index) {
  let i = index;
  let html = '';
  let stage = '';
  if (typeof trace === 'undefined') return html;
  const message = trace[index].m;
  if (index >= trace.gpos_point) 
    stage = 'GPOS';
  else if (index >= trace.gsub_point)
    stage += 'GSUB';
  html += stage + ' #'+i+': ';
  html += message;
  return html;
}

function findLastLookup(trace, index) {
  let res = [];
  let found = false;
  if (index >= trace.gpos_point) res.stage = 'GPOS';
  else if (index >= trace.gsub_point) res.stage = 'GSUB';
  while (!found && (index > 0)) {
    let debugInfo = null;
    const message = trace[index].m;
    const m3 = message.match(/^start lookup (\d+) feature '(\w+)'/);
    const m4 = message.match(/^recursing to lookup (\d+) at (\d+)/);
    if (m3) {
      res.push( {
        t: parseInt(m3[1], 10),
      });
      found = true;
    }
    if (m4) {
      res.push({
        t: parseInt(m4[1], 10),
        g: parseInt(m4[2], 10),
      });
    }
    index--;
  }
  return res;
}

function generateBuffer(text, options) {
  let buffer = hb.createBuffer();
  buffer.addText(text);
  buffer.guessSegmentProperties();
  if (options.direction && options.direction.length > 0) {
    buffer.setDirection(options.direction || 'ltr');
  }
  if (options.script && options.script.length > 0) {
    buffer.setScript(options.script || 'latn');
  }
  if (options.language && options.language.length > 0) {
    buffer.setLanguage(options.language);
  }
  return buffer;
}

function transferResult(result, trace_entry, hb_entry, index) {
  let re = {};
  re.g = trace_entry.g;
  re.cl = trace_entry.cl;
  re.i = index;
  if (typeof trace_entry.ax === 'undefined') {
    re.ax = NaN; // This is picked up later and we use the glyphs max.x to advance
    re.ay = 0;
    re.dx = 0;
    re.dy = 0;
    re.flags = 0;
  } else {
    re.ax = trace_entry.ax;
    re.ay = trace_entry.ay;
    re.dx = trace_entry.dx;
    re.dy = trace_entry.dy;
    re.flags = trace_entry.flags;
  }
  re.H = trace_entry.H
  result.push(re);
}

function createResultArrayFromTrace(font, trace, hb_result) {
  // NOTE: hb_result[0].cl shows us which direction we should generate
  //       compared to the trace.cl
  // NOTE: in the case of a GSUB sequence, we can take the ax,ay,dx,dy from the hb_result
  //       to show meaningful info (that HarfBuzz has slightly cooked)
  let result = [];
  const tr = trace[trace.length - 1];
  const t = tr.t;
  if (typeof t === 'undefined') return result;

  // Scan for ' at ...' in the tr.m field
  let sets = tr.m.match(/ at [\d,]+/g);
  if (sets !== null) {
    let i = 0;
    while (i < sets.length) {
      const indices = sets[i].match(/\d+/g);
      let j = 0;
      while (j < indices.length) {
        const n = parseInt(indices[j], 10);
        t[n].H = i+1;
        j++;
      }
      i++;
    }
  }

  if (hb_result[0].cl == t[0].cl) {
    // Same direction
    let i = 0;
    while (i < t.length) {
      const te = t[i];
      if (typeof te === 'undefined') break;
      transferResult(result, te, hb_result[i], i);
      i++;
    }
  } else {
    // Need to reverse
    let i = t.length - 1;
    let hi = 0;
    while (i >= 0) {
      const te = t[i];
      transferResult(result, te, hb_result[hi], i);
      hi++;
      i--;
    }
  }
  return result;
}

function isHarfBuzzMessageImportant(msg) {
  const set = [
    'multiplying', 'multiplied',
    'replacing',   'replaced',
    'ligating',    'ligated',
    'kerning',     'kerned',
    'attaching',   'attached',
    'positioning', 'positioned',
    'deleting',    'deleted',
  ];
  const size = set.length;
  for (let i=0;i<size;i++) {
    if (msg.includes(set[i])) return true;
  }
  return false;
}

function findNextEvent(obj, text, startIndex, forward=true) {
  obj = obj || {};
  if (!("blob" in obj)) obj.blob = hb.createBlob(obj.fontBlob);
  if (!("face" in obj)) obj.face = hb.createFace(obj.blob, 0);
  if (!("font" in obj)) obj.font = hb.createFont(obj.face);
  const font = obj.font;
  const limits = {maxGlyphRatio:100.0, maxDepth:100};
  let options = obj.options;

  let buffer = generateBuffer(text, options);
  let featureString = '';
  if (options.featureString && options.featureString.length > 0) {
    featureString = `+DUMY,${options.featureString},`; // Copied from Crowbar... "SERIOUSLY?"
  }

  let trace = hb.shapeWithTraceLimits(font, buffer, featureString, null/*hb_stop_at*/, null/*hb_stop_phase*/, limits, null);
  const max = trace.count;

  if (startIndex < 0) {
    if (forward)
      startIndex = 0;
    else
      startIndex = max;
  }
  let index = startIndex;

  for (let i=0; i<max; i++) {
    const t = trace[i];
    const msg = t.m;
    if (msg && isHarfBuzzMessageImportant(msg)) {
      if (forward) {
        if (i > startIndex) {
          index = i;
          break;
        }
      } else {
        if (i < startIndex) {
          index = i;
        }
        if (i >= startIndex)
          break;
      }
    }
  }
  buffer.destroy();
  return index;
}

function timeLinePrev() {
  scrubber.value = findNextEvent(hbsvg1, text.value, scrubber.value-1, false)+1;
  updateResult();
}

function timeLineNext() {
  scrubber.value = findNextEvent(hbsvg1, text.value, scrubber.value-1, true)+1;
  updateResult();
}

function timeLineGsubEnd() {
  scrubber.value = hbsvg1.trace.gpos_point;
  updateResult();
}

function hbToSvg(obj, text, options, doTimeline, doUpdateScrubInfo)
{
  obj = obj || {};
  if (!("blob" in obj)) obj.blob = hb.createBlob(obj.fontBlob);
  if (!("face" in obj)) obj.face = hb.createFace(obj.blob, 0);
  if (!("font" in obj)) obj.font = hb.createFont(obj.face);
  let font = obj.font;
  const primary = doUpdateScrubInfo; //(obj == hbsvg1);
  if ("scale" in options)
    font.setScale(options.scale, options.scale); // Optional, if not given will be in font upem

  let buffer = generateBuffer(text, options);
  let featureString = '';
  if (options.featureString && options.featureString.length > 0) {
    featureString = `+DUMY,${options.featureString},`; // Copied from Crowbar... "SERIOUSLY?"
  }
  const limits = {maxGlyphRatio:100.0, maxDepth:100};

  let stop_count = null;
  if (scrubber.value > 0) stop_count = scrubber.value;
  const stop_at = (stop_count>0) ? null : hb_stop_at;
  const stop_phase = (stop_count>0) ? null : hb_stop_phase;

  obj.trace = hb.shapeWithTraceLimits(font, buffer, featureString, stop_at, stop_phase, limits, null);
  
  let result;
  // NOTE: doTimeline is currently always true ;-)
  if (doTimeline) {
    scrubber_count.innerText = obj.trace.count;
    let buffer_trace = generateBuffer(text, options);
    if (hbBrowserMode && !stop_count) {
      obj.trace_part = hb.shape(font, buffer_trace, featureString);
    } else {
      obj.trace_part = hb.shapeWithTraceLimits(font, buffer_trace, featureString, 
                                                 stop_at, 
                                                 stop_phase,
                                                 limits,
                                                 stop_count);      
    }

    if (stop_count > 0)
      result = createResultArrayFromTrace(font, obj.trace_part, buffer_trace.json(font));
    else
      result = buffer_trace.json(font);

    buffer_trace.destroy();
    if (primary) {
      if (!stop_count) {
        // Update the scrubber limits as we have a 'full' shaping count info
        scrubber.max = obj.trace.count;
        scrubber_text.innerText =
          ' GSUB:'+obj.trace.gsub_point +
          ' GPOS:'+obj.trace.gpos_point +
          ' Total:'+obj.trace.count;
      } else {
        let idx = stop_count - 1; //obj.trace.length - 1;
        let html = generateHtmlForTrace(obj.trace, idx);
        let lastLookup = findLastLookup(obj.trace, idx);
        if (lastLookup.length > 0) {
          let extra_html = '</br><font color="#811">';
          let found_debug = false;
          lastLookup.forEach( function(v) {
            const debugInfo = obj.getDebugInfo(v.t, lastLookup.stage);
            extra_html += ` &lArr; #${v.t}`;
            if (debugInfo) {
              const gposName = debugInfo.name ? debugInfo.name : ``;
              extra_html += `: <font color='red'>${debugInfo.source}</font> : <b>${gposName}</b>`;
              found_debug = true;
            } else {
              //
            }
            if (typeof v.g !== 'undefined') {
              // Find glyph index in result...
              const gidFound = result.find((r) => (r.i == v.g));
              const gid = gidFound?.g;
              extra_html += ` <font color='#066'>@${v.g}=${gid}`;
              const gidName = hbsvg1.getGlyphName(gid);
              if (gidName) extra_html += `:${gidName}`;
              extra_html += '</font>';
            }
            extra_html += '</br>';
          });
          extra_html += '</font>';
          html += extra_html;
        }
        scrubber_text.innerHTML = html;
      }
    }
  } else {
    result = buffer.json(font);
  }

  // returns glyphs paths, totally optional
  let glyphs = {};
  //let paths  = {};
  result.forEach(function (x) {
    if (glyphs[x.g]) return;
    glyphs[x.g] = font.glyphToJson(x.g);
    //paths[x.g]  = font.glyphToPath(x.g);
  });
  buffer.destroy();

  let opacf = options.opacity_fill; // || 0.7
  let opacs = options.opacity_stroke;// || 0.3;
  let stroke_width = options.stroke_width || 11;
  let x_stretch = options.x_stretch || 0;
  let svgPath = '';
  let x = options.x || 0;
  let y = options.y || 0;
  let colour_i = 0;
  let cluster_n = -1;
  let colour_mode = options.colour_mode || 0;
  let colour_solid = options.colour_solid || '#f37418'; // #0523d4 (blue)
  let r;
  let idx = 0;
  let n = 0;

  for (r of result) {
    let colourGlyph = colour_solid;
    let colourStroke = colour_solid;
    let colourText = colour_solid;
    let colourExtents = colour_solid;
    if (!colour_mode == 0)
    {
      if (colour_mode == 1) {
        colour_i++;
      } else
      if (colour_mode == 2) {
        if (cluster_n != r.cl) {
          colour_i++;
        }
      }
      cluster_n = r.cl;
      colourGlyph   = glyphColors[colour_i%glyphColors.length];
      colourStroke  = colour_solid;
      colourText    = colourGlyph;
      colourExtents = colourGlyph;
    } else {
      colour_i++;
      colourStroke  = glyphColors[colour_i%glyphColors.length];
      colourText    = colourStroke;
      colourExtents = colourStroke;
    }
    let blendMode = options.blendMode || 'normal';
    let ext = {};
    const glyphSvg = jsonToSvg(glyphToRelative(glyphs[r.g], false, ext));
    if (isNaN(r.ax)) {
      // for GSUB phase where there's no advance
      // (r.ax will be set to -1 in `transferResult`)
      if (ext.w <= 1) ext.w = (obj.face.upem / 6);
      if (ext.xl < 0) r.dx = -ext.xl
      if (ext.xh > ext.w) r.ax = ext.xh; else r.ax = ext.w;
    }
    let path = '';
    if (showBoundingBox.checked && primary) {
      path += '<rect style="fill:'+colourExtents
           +';fill-opacity:0.15;mix-blend-mode:\'multiply\'" '
           +'width="'+(ext.w)+'"'
           +'height="'+(ext.h)+'"'
           +'x="'+(x+r.dx+ext.xl)+'" y="'+(y-r.dy-ext.yh)+'"'
           +'/>'
    }
    if (r.H && primary) {
      let highlight_fill, highlight_stroke;
      if (r.H == 1) {
        highlight_fill   = '#ffff00';
        highlight_stroke = '#ff0000';
      }
      else {
        highlight_fill   = '#ffff00';
        highlight_stroke = '#80c000';
      }
      path += '<rect style="fill:'+highlight_fill+';fill-opacity:0.6;mix-blend-mode:normal;'
              +'stroke-opacity:0.5;stroke-width:20;stroke:'+highlight_stroke+'"'
           +'width="'+(ext.w)+'"'
           +'height="'+(ext.h)+'"'
           +'x="'+(x+r.dx+ext.xl)+'" y="'+(y-r.dy-ext.yh)+'"'
           +'/>'
    }
    if (showOrigin.checked && primary) {
      path += '<circle r="'+(20* options.scale / 1000)+'"'
           +'style="fill-opacity:0.5;" '
           +'cx="'+(x+r.dx)+'" '
           +'cy="'+(y-r.dy)+'" '
           +'fill="'+colourExtents+'" />'
    }
    path +=
        '<path '+
          'id="n'+n+'_g'+r.g+'_c'+r.cl+'"'+
          'style="fill:'
          +colourGlyph
          +';stroke:'+colourStroke
          //+';paint-order:stroke'+
          +';fill-opacity:'+opacf+';stroke-opacity:'+opacs+';stroke-width:'+stroke_width
          +'; mix-blend-mode:\''+blendMode+'\'" '
        +'d="M'+x+' '+y+' '         // The absolute origin
        +'m'+r.dx+' '+(-r.dy)+' '   // negative y because the SVG coordinates are upside down
        +glyphSvg
        +'"/>\r\n';
    if (primary && (options.showGids || options.showGidNames)) {
      let xOfs = 0; //r.dx
      let fontSize = 95 * options.scale / 1000;
      let yOfs = -650 - (idx % 5) * 100;
      let name = obj.getGlyphName(r.g);
      let gid = r.g;
      const isMark = obj.isGlyphClassMark(r.g);
      if (isMark) gid = '\''+gid;

      if (options.showGidNames && name) {
        if (options.showGids) {
          gid = gid + ':' + name;
        } else {
          gid = name;
          if (isMark) gid = `(${gid})`;
        }
      }
      yOfs = yOfs * options.scale / 1000;
      path += '<text font-size="'+fontSize+'" x="'+(x+xOfs)+'" y="'+(y-yOfs)+'" fill="'+colourText+'">'+gid+'</text>';
      idx++;
    }
    svgPath += path;
    x += r.ax + x_stretch;
    y += r.ay;
    n++;
  }
  obj.results.x_end = x;
  obj.results.y_end = y;
  obj.results.svgPath = svgPath;
  obj.results.json = result; // the JSON result
  return svgPath;
}

function textToUnicode(str) {
  return str.split('').map(function (value, index, array) {
    let temp = value.charCodeAt(0).toString(16); //.toUpperCase();
    return temp;
  }).join(' ');
}

function unicodeToText(uni, maxLength) {
  let txt = uni.split(' ').map(function(value, index, array) {
    if (value.length == 0) return '';
    return String.fromCharCode('0x'+value);
  }).join('');
  if (maxLength) txt = txt.slice(0, maxLength); // Keep only 100 characters
  return txt;
}

function resetScrubber() {
  scrubber.value = 0;
}

function UpdateUnicode(e) {
  text.value = unicodeToText(unicode.value, 100);
  resetScrubber();
  updateResult();
}

function UpdateText(e) {
  resetScrubber();
  text.value = text.value.slice(0, 100); // throw away silly amounts of text. Keep only 100 characters
  unicode.value = textToUnicode(text.value);
  updateResult();
}

function UpdateScrubber(e) {
  updateResult();
}

function onlyGSUBUpdate(e) {
  if (onlyGSUB.checked)
    hb_stop_phase = 1;
  else
    hb_stop_phase = null;
  updateResult();
}

function UpdateWithTimeline(e) {
  updateResult();
  updateLists();
  resetScrubber();
}

function acquireFontAndLists() {
  if (!window.opener) return;
  const w = window.opener;
  if (!isExists(w.api) || !isExists(w.api.transfer)) return;
  const xfer = w.api.transfer;  // Use this as a conduit for values to be passed in here
  updateTransfer(xfer);
}

function updateTransfer(xfer) {
  // Get values from the other tool...
  if (!xfer) return;
  if (isExists(xfer.fontBlob1)) hbsvg1.setFontBlob(xfer.fontBlob1);
  if (isExists(xfer.fontBlob2)) hbsvg2.setFontBlob(xfer.fontBlob2);
  if (isExists(xfer.checkList) && (xfer.checkList.length > 0)) {
    mya = [];
    let i = 0;
    while (i < xfer.checkList.length) {
      mya.push(xfer.checkList[i]);
      i++;
    }
    hideTextButtons(false);
  }
  if (xfer.script !== null)   script.value   = xfer.script;
  if (xfer.language !== null) language.value = xfer.language;
  updateControls();
  gotoLineFirst();
}

function indexKeyDown(event) {
  if (event.code == 'Enter') {
    gotoLineIndex();
  }
}

function setBrowserMode(hbMode) {
  if (typeof hbMode == 'boolean') {
    hbBrowserMode = hbMode;
    scrubber.disabled = hbMode;
    tlGsubEnd.disabled = hbMode;
    tlNext.disabled = hbMode;
    tlPrev.disabled = hbMode;
    updateResult();
  }
  return hbBrowserMode;
}

// Glue update events...
UpdateListener('text', 'keyup', UpdateText);
UpdateListener('unicode', 'keyup', UpdateUnicode);
UpdateListener('script', 'keyup', UpdateWithTimeline);
UpdateListener('language', 'keyup', UpdateWithTimeline);
UpdateListener('dirLTR', 'input', UpdateWithTimeline);
UpdateListener('dirRTL', 'input', UpdateWithTimeline);
UpdateListener('stretch', 'input');
UpdateListener('offset2', 'input');
UpdateListener('opacityFill', 'input');
UpdateListener('opacityStroke', 'input');
UpdateListener('strokeWidth', 'input');
UpdateListener('opacityFill2', 'input');
UpdateListener('opacityStroke2', 'input');
UpdateListener('strokeWidth2', 'input');
UpdateListener('colourGlyph', 'input');
UpdateListener('colourCluster', 'input');
UpdateListener('colourSolid', 'input');
UpdateListener('solid1', 'input');
UpdateListener('colourGlyph2', 'input');
UpdateListener('colourCluster2', 'input');
UpdateListener('colourSolid2', 'input');
UpdateListener('solid2', 'input');
UpdateListener('scale', 'input');
UpdateListener('showGids', 'input');
UpdateListener('showGidNames', 'input', handleGidNamesChanged);
UpdateListener('features', 'input', UpdateWithTimeline);
UpdateListener('baseLine', 'input');
UpdateListener('cbDifference', 'input');
UpdateListener('showBoundingBox', 'input');
UpdateListener('showOrigin', 'input');
UpdateListener('onlyGSUB', 'input', onlyGSUBUpdate);
UpdateListener('exclusion', 'input');
UpdateListener('scrubber', 'input', UpdateScrubber);
UpdateListener('inputIndex', 'keydown', indexKeyDown);
resetScrubber();

// Expose these to the window
window.zoomSVG = zoomSVG;
window.DownloadSvg = DownloadSvg;
window.copyTraceToClipboard = copyTraceToClipboard;
window.gotoLineFirst = gotoLineFirst;
window.gotoLineOfs = gotoLineOfs;
window.gotoLineLast = gotoLineLast;
window.gotoLineIndex = gotoLineIndex;
window.SwapFonts = SwapFonts;
window.ResetFontTwo = ResetFontTwo;
window.timeLinePrev = timeLinePrev;
window.timeLineGsubEnd = timeLineGsubEnd;
window.timeLineNext = timeLineNext;
window.updateResult = updateResult;
window.updateTransfer = updateTransfer;
window.setBrowserMode = setBrowserMode;

window.hbsvg1 = hbsvg1;
window.hbsvg2 = hbsvg2;
window.loadHarfBuzzVersion = loadHarfBuzzVersion;

async function hbVersionChange(event) {
  /*
  let url = new URL(document.location.toString());
  url.search = `?hb=${cbHarfBuzzVersion.value}`;
  window.location.replace(url.href);
  */
  const version = cbHarfBuzzVersion.value;
  await loadHarfBuzzVersion(version);
  //setHarfBuzz(hbVersions[version]);
  //updateResult();
  //~~//console.log('hbVersionChange', version, hb.version_string()); //~~
  //~~//hbversion.innerHTML = hb.version_string();
}

function populateHarfBuzzVersionChoice() {
  const hbVersionsAvailable = [
    '12.3.0',
    '12.2.0',
    '12.0.0',
    '11.5.0',
    '11.4.5',
    //'11.4.4',
    //'11.4.1',
    '11.3.3',
    '11.0.1',
  ];
  let html = '<select name="hbVersion" id="cbHarfBuzzVersion">\r\n';
  let knownVersion = false;
  const hb_version = hbsvg1.hbVersion;
  hbVersionsAvailable.forEach(v=> {
    const thisVersion = (hb_version == v);
    if (thisVersion) knownVersion = true;
    html += `<option value="${v}"${thisVersion?" selected":""}>${v}</option>\r\n`;    
  });
  html += '</select>';
  if (!knownVersion) {
    const hbv = hb.version_string();
    if (hbv) {
      //??//hbversion.innerHTML = hbv;
    }
  }
  hbVersionChoice.innerHTML = html;
  UpdateListener('cbHarfBuzzVersion', 'change', hbVersionChange);
}

function setHarfBuzz(hbNew) {
  hbsvg1.setHarfBuzz(hbNew);
  hbsvg2.setHarfBuzz(hbNew);
  hb = hbNew;
}

//populateHarfBuzzVersionChoice();

</script>
HarfBuzz Version: <span id="hbversion"></span> <span id='hbVersionChoice'>fillmein</span>
<p>Also useful: <a href="https://www.corvelsoftware.co.uk/crowbar/" target="_blank">Crowbar Font Tester (Simon Cozens)</a>.
<br/>github: <a href="https://github.com/MattMatic/hbfontcompare" target="_blank">MattMatic/hbfontcompare</a>
</br>Tool Version: 2025-12-31 h
</p>
</html>
