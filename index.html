<html>
<head>
  <title>HarfBuzz JS Font Compare Tool</title>
  <style>
body {
  font-family: "Calibri";
  background-color: #c0e0c0;
}
table, th, td {
  border-collapse: collapse;
  border: 2px solid #c0d0c0;
  padding: 3px;
}
.label {
  text-align: right;
  font-weight: bold;
}
.svg {
  background-color: #f0f8f0;
  padding:6px;
}
.codes {
  font-family: 'Lucida Console';
  font-size: 70%;
}
input {
  background-color: #d0e0d0;
  accent-color: #608060;
}
input[type="range"] {
  background-color: #d0e0d0;
  accent-color: #586858;
  width: 35%;
}
button {
  background-color: #c0d0c0;
}
#text {
  font-size: 150%;
}
#script,#language {
  font-family: 'Lucida Console';
}
#shapeResult1,#shapeResult2 {
  font-family: 'Lucida Console';
  font-size: 80%;
}
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #ccc;
  color: #006080;
}
.tooltip .tooltiptext {
  visibility: hidden;
  position: absolute;
  width: 340px;
  background-color: #555;
  color: #fff;
  text-align: center;
  padding: 5px 0;
  border-radius: 6px;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.tooltip-bottom {
  top: 135%;
  left: 50%;
  margin-left: -60px;
}
.tooltip-bottom::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  margin-width: 5px;
  border-style: solid;
  border-color: transparent transparent #555 transparent;
}

#scrubber {
  width: 80%;
  margin: 0;
}

  </style>
</head>
<meta charset="utf-8">
<h1>HarfBuzz JS Font Compare</h1>

<table border=1 width="100%">
  <tr>
    <td class='label'width="10%">Text:</td>
    <td colspan=2 id='textdrop'>
      <input type="text" value="abc" id="text">
      <button id="btnGotoLineFirst" onclick="gotoLineFirst();" accesskey='1' hidden>First (Alt-1)</button>
      <button id="btnGotoLinePrev" onclick="gotoLineOfs(-1);" accesskey='2' hidden>Prev (Alt-2)</button>
      <button id="btnGotoLineNext" onclick="gotoLineOfs(1);" accesskey='3' hidden>Next (Alt-3)</button>
      <button id="btnGotoLineLast" onclick="gotoLineLast();" accesskey='4' hidden>Last (Alt-4)</button>
    </td>
  </tr>
  <tr>
    <td class='label'width="10%">Hex:</td>
    <td colspan=2>
      <input type="text" size="100" value="61 62 63" id="unicode">
    </td>
  </tr>
  <tr><td class='label' width="10%">Script/Lang/Dir:</td>
    <td colspan=2>
      <span class='tooltip'><input type="text" value="" id="script">
        <span class='tooltiptext tooltip-bottom' id='scriptList'>-</span>
      </span>,
      <span class='tooltip'><input type="text" value="" id="language">
        <span class='tooltiptext tooltip-bottom' id='languageList'>-</span>
      </span>
      <input type="radio" id="dirLTR"   name="direction" value="LTR" checked>
        <label for="dirLTR">LTR</label>
      <input type="radio" id="dirRTL"   name="direction" value="RTL">
        <label for="dirRTL">RTL</label>
    </td></tr>
  <tr><td class='label' width="10%">Features:</td>
    <td>
      <span class="tooltip">
        <input type="text" value="" id="features">
        <span id='featureList' class='tooltiptext tooltip-bottom'></span>
      </span>
      <font size=-1>e.g. '-liga,+jalt,+ss02'</font>
    </td></tr>

  <!--<tr><td>Font:</td><td><input type="text" value="" id="fontFile1"></td></tr>-->
  <tr><td class='label' >Font Drag & Drop:</td><td id='dropOne'>
      <button type="button" id="swapFonts" onclick="SwapFonts();">Swap #1 & #2</button>
    </td><td id='dropTwo'>
    <button type="button" id="resetFontTwo" onclick="ResetFontTwo();">Reset #2</button>
  </td></tr>
  <tr>
    <td class='label'>Font:</td>
    <td id='dropName1'><div id='fontName1'></div></td>
    <td id='dropName2'><div id='fontName2'></div></td>
  </tr>
  <tr><td class='label' >Scale:</td>
    <td colspan=1>
      <input type="range" value="1000" min="100" max="4000" step="10" id="scale" ondblclick="scale.value=1000; updateResult();">
        <label for="scale" id="scaleLabel">1000</label>
    </td>
  </tr>
  <tr><td class='label' >Stretch/Offset:</td>
    <td><input type="range" value="0" min="0" max="500" id="stretch"></td>
    <td><input type="range" value="0" min="0" max="4000" id="offset2"></td>
  </tr>
  <tr><td class='label' >Color:</td>
  <td>
    <input type="radio" id="colourGlyph"   name="colour" value="glyph">
      <label for="colourGlyph">Glyph</label>
    <input type="radio" id="colourCluster" name="colour" value="cluster">
      <label for="colourCluster">Cluster</label>
    <input type="radio" id="colourSolid"   name="colour" value="solid" checked>
      <label for="colourSolid">Solid</label>
    <input type="text" id="solid1" value="#202080">
    </td>
    <td>
    <input type="radio" id="colourGlyph2"   name="colour2" value="glyph">
      <label for="colourGlyph2">Glyph</label>
    <input type="radio" id="colourCluster2" name="colour2" value="cluster">
      <label for="colourCluster2">Cluster</label>
    <input type="radio" id="colourSolid2"   name="colour2" value="solid" checked>
      <label for="colourSolid2">Solid</label>
    <input type="text" id="solid2" value="#f37418">
    </td>
  </tr>
  <tr><td class='label'>Opacity Fill:</td>
    <td>
      <input type="range" value="0.7" min="0" max="1.0" step="0.01" id="opacityFill">
    </td>
    <td>
      <input type="range" value="0.3" min="0" max="1.0" step="0.01" id="opacityFill2">
    </td>
  </tr>
  <tr><td class='label'>Opacity Stroke:</td>
    <td>
      <input type="range" value="0.0" min="0" max="1.0" step="0.01" id="opacityStroke">
    </td>
    <td>
      <input type="range" value="0.0" min="0" max="1.0" step="0.01" id="opacityStroke2">
    </td>
  </tr>
  <tr><td class='label'>Stroke Width:</td>
    <td>
      <input type="range" value="7" min="1" max="51" step="1" id="strokeWidth">
    </td>
    <td>
      <input type="range" value="7" min="1" max="51" step="1" id="strokeWidth2">
    </td>
  </tr>
  <tr>
    <td class='label'>Options:</td>
    <td>
      <input type="checkbox" id="showGids"><label for="showGids">GIDs</label>
      <input type="checkbox" id="baseLine"><label for="baseLine">Baseline</label>
      <input type="checkbox" id="showBoundingBox"><label for="showBoundingBox">Bounding Box</label>
      <input type="checkbox" id="showOrigin"><label for="showOrigin">Origins</label>
      <!--<input type="checkbox" id="exclusion"><label for="exclusion">Exclusion</label>-->
      <!--<input type="checkbox" id="showBbox"><label for="showBbox">Bounds</label>-->
    </td>
    <td></td>
  </tr>
<!--<p>Colour: <input type="checkbox" id="colourEnabled" checked></p>-->

<tr><td class='svg' colspan=3>
<!--<a id="svgResult" href="#" title="Click to download"></a>-->
<div class='svg' id='svgResult'></div>
<p><button id="saveSvg" onclick="DownloadSvg();">Download SVG</button>
  <button id="zoomOutSVG" onclick="zoomSVG(-1);">-</button>
  <button id="zoomResetSVG" onclick="zoomSVG(0);" title="Middle click or Shift-Left and drag to pan the SVG">100%</button>
  <button id="zoomInSVG" onclick="zoomSVG(1);">+</button>
</td></tr>
<tr>
  <td class='label'>Timeline:</td>
  <td colspan=2>
    <input type="range" id='scrubber' name='scrubber' min=0 max=242 value=0/><span id='scrubber_count'></span>
    </br><span class='codes' id='scrubber_text'></span>
</td></tr>
<tr>
  <td class='label' width='10%'>HarfBuzz:</td>
  <td width='45%'><div id='harfBuzzResult1'></div><button type="button" id="copyHB1" onclick="copyTraceToClipboard(hbsvg1);">Copy Trace #1</button></td>
  <td width='45%'><div id='harfBuzzResult2'></div><button type="button" id="copyHB1" onclick="copyTraceToClipboard(hbsvg2);">Copy Trace #2</button></td>
</tr>
<tr>
  <td class='label' width="10%">Result:</td>
  <td width='45%'><div id='shapeResult1'></div></td>
  <td width='45%'><div id='shapeResult2'></div></td>
</tr>
</table>
<!--
<p>Debug1:<div id="debugResult"></div></p>
<p>Debug2:<div id="debugResult2"></div></p>
<p>Debug3:<div id="debugResult3"></div></p>
--->

<script type="text/javascript" src="hb.js"></script> <!-- Module - REQUIRED -->
<script type="text/javascript" src="hbjs.js"></script> <!-- Wrapper, can be used without -->
<script type="text/javascript" src="otinfo.min.js"></script>
<script>
'use strict';

function isExists(v) {
  if ((typeof(v) === 'object') && (v === null)) return false;
  return typeof(v) !== 'undefined';
}

//----------------------------------
// Matt Page / MattMatic
// 2024
//----------------------------------

// Used for colouration of glyphs or clusters
const glyphColors = ['#bb87e3','#bc6b0e','#57118c','#64902e','#91bbec','#d65e02','#1d5799','#984c11','#271909'];
var textLineInfo = null;
var textLineFileName = '';

//------------------------------
// Drag and drop utilities
//------------------------------
function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);

//----------------------------------
// HarfBuzz SVG Class
//----------------------------------
class hbSvgClass {
  constructor() {
    this.options = {};
    this.results = {};
  }
  destroy() {
    this.freeFont();
    delete(this.fontBlob);
  }
  freeFontBlob() {
    this.freeFont();
    this.fileDescription = null;
    delete(this.fontBlob);
  }
  freeFont() {
    this.results = {};
    if (this.font) { this.font.destroy(); delete(this.font); }
    if (this.face) { this.face.destroy(); delete(this.face); }
    if (this.blob) { this.blob.destroy(); delete(this.blob); }
  }
  doGtable(t) {
    if (!t) return;
    if (t.scriptTable) {
      for (const key in t.scriptTable) {
        this.fontInfo.scripts.add(key);
        for (const val of t.scriptTable[key]) {
          this.fontInfo.languages.add(val);
        }
      }
    }
    if (t.featureListTable) {
      for (const val of t.featureListTable) {
        this.fontInfo.features.add(val);
      }
    }
  }
  fillTables() {
    this.fontInfo.scripts = new Set();
    this.fontInfo.languages = new Set();
    this.fontInfo.features = new Set();
    this.doGtable(this.fontInfo.GSUB);
    this.doGtable(this.fontInfo.GPOS);
  }
  setFontBlob(fb) {
    this.freeFont();
    this.fontBlob = fb;
    this.fontInfo = null;
    if (fb) {
      const otInfo = OTInfo.parse(fb);
      this.fontInfo = otInfo[0];
      const fontName = this.fontInfo.name;
      //console.log(fontName);
      this.fileDescription = fontName.fullName + '</br>' + fontName.version;
      this.fillTables();
    } else {
      this.fileDescription = '';
    }
    if (!fb) return;
    this.blob = hb.createBlob(this.fontBlob);
    this.face = hb.createFace(this.blob, 0);
    this.font = hb.createFont(this.face);
  }
  copyOptions(fromOptions) {
    this.options = structuredClone(fromOptions);
  }
  toSvg(text, doTimeline, doUpdateScrubInfo) {
    return window.hbToSvg(this, text, this.options, doTimeline, doUpdateScrubInfo);
  }
  swapWith(other) {
    var b1 = this.fontBlob;
    var b2 = other.fontBlob;
    this.setFontBlob(b2);
    other.setFontBlob(b1);
  }
}

var hb;
var hbsvg1 = new hbSvgClass();
var hbsvg2 = new hbSvgClass();

function SwapFonts() {
  hbsvg1.swapWith(hbsvg2);
  updateResult();
  updateLists();
}

function ResetFontTwo() {
  hbsvg2.freeFontBlob();
  updateResult();
}

function formatJson(json) {
  return JSON.stringify(json).replace('[', '[\r\n').replace(/},/g, '},\r\n');
}

function DownloadSvg() {
  var tempLink = document.createElement("a");
  var taBlob = new Blob([svgResult.innerHTML.replace(' height="512"', '')], { type: 'text/plain' });
  tempLink.setAttribute('href', URL.createObjectURL(taBlob));
  tempLink.setAttribute('download', text.value + '.svg');
  tempLink.click();
  URL.revokeObjectURL(tempLink.href);
}

function hideTextButtons(dohide) {
  btnGotoLineFirst.hidden = dohide;
  btnGotoLinePrev.hidden = dohide;
  btnGotoLineNext.hidden = dohide;
  btnGotoLineLast.hidden = dohide;
}

var lineNo = 0;
var mya = [];

function LoadLine() {
  if (lineNo < 0) lineNo = 0;
  if (lineNo >= mya.length) lineNo = mya.length - 1;
  while ((lineNo > 0) && !mya[lineNo]) lineNo--;
  while ((lineNo < mya.length) && !mya[lineNo]) lineNo++;
  if (mya[lineNo]) {
    text.value = mya[lineNo];
    textLineInfo = '#'+(lineNo+1)+"/"+mya.length+ ' ('+textLineFileName+')';
    UpdateText();
  }
}

function gotoLineFirst() {
  lineNo = 0;
  LoadLine();
}

function gotoLineOfs(ofs) {
  lineNo += ofs;
  LoadLine();
}

function gotoLineLast() {
  lineNo = mya.length - 1;
  LoadLine();
}

function updateTextLines(textLines) {
  mya = textLines.split(/\r?\n+/g);
  mya = mya.flat();
}

function iterateGtable(gtable, theKey, outputset) {
  if (!gtable) return;
  const scriptTable = gtable.scriptTable;
  if (!scriptTable) return;
  if (!scriptTable[theKey]) return;
  for (const y of scriptTable[theKey]) {
    outputset.add(y);
  }
}

function updateLists() {
  // Update script, language, and feature lists from this.fontInfo
  const fontInfo = hbsvg1.fontInfo;
  scriptList.innerText = '(empty)';
  languageList.innerText = '(empty)';
  featureList.innerHTML = '(empty)';
  if (!fontInfo) {
    return;
  }
  //console.log(fontInfo);
  //console.log(fontInfo.scripts, fontInfo.languages, fontInfo.features);
  if (fontInfo.scripts.size > 0) {
    scriptList.innerText = '"'+[...fontInfo.scripts].sort().join('", "')+'"';
  }
  var languages = fontInfo.languages;

  if (script.value !== '') {
    var theScript = script.value.toLowerCase();
    languages = new Set();
    iterateGtable(fontInfo.GSUB, theScript, languages);
    iterateGtable(fontInfo.GPOS, theScript, languages);
  }
  if (languages.size > 0) {
    languageList.innerText = '"'+[...languages].sort().join('", "')+'"';
  }
  if (fontInfo.features.size > 0) {
    featureList.innerHTML = [...fontInfo.features].sort().join(", ");
  }
}

function getHarfBuzzResult(hbsvg) {
  var txt = ''
  if (hbsvg.trace.limits.maxGlyphAbort) txt += "<font color='red'>!GLYPH COUNT! "+hbsvg.trace.limits.maxGlyph+"</font></br>\r\n";
  if (hbsvg.trace.limits.maxDepthAbort) txt += "<font color='red'>!GSUB/GPOS DEPTH!</font></br>\r\n" + txt;
  if (hbsvg.trace && hbsvg.trace.limits) {
    txt += 'GSUB/GPOS Depth: '+hbsvg.trace.limits.maxDepth + '</br>\r\n';
  }
  return txt;
}

function getTraceJSON(hbsvg) {
  var txt = '';
  txt += '{"font":"'+hbsvg.fileDescription+'",\r\n'+
         ' "text":"'+text.value+'",\r\n'+
         ' "script":"'+script.value+'",\r\n'+
         ' "language":"'+language.value+'",\r\n'+
         ' "features":"'+features.value+'",\r\n'+
         ' "count":' + hbsvg.trace.count+',\r\n';
  if (hbsvg.trace.gsub_point > 0)
        txt += ' "gsub_start:":' + hbsvg.trace.gsub_point+',\r\n';
  if (hbsvg.trace.gpos_point > 0)
        txt += ' "gpos_start:":' + hbsvg.trace.gpos_point+',\r\n';
  if (scrubber.value > 0) {
    txt += ' "stop_at":'+scrubber.value+',\r\n';
  }
  txt += ' "dir":"';
  if (dirRTL.checked) txt += 'RTL'; else txt += 'LTR';
  txt += '"},\r\n';
  txt += '[\r\n';
  for (let o of hbsvg.trace) {
    txt += (" ".repeat(o.d || 0)) + JSON.stringify(o)+',\r\n';
  }
  txt += ']';
  return txt;
}

function copyTraceToClipboard(hbsvg) {
  navigator.clipboard.writeText(getTraceJSON(hbsvg));
}

function getShapeResult(hbsvg) {
  return formatJson(hbsvg.results.json || '');
}

function updateSvg(dive, html) {
  var oldScale = 1;
  var oldTranslate = {x:0, y:0};

  var svge = dive.children[0];
  if (typeof svge !== 'undefined') {
    oldScale = svge.currentScale;
    oldTranslate = svge.currentTranslate;
  }
  dive.innerHTML = html;
  svge = dive.children[0];
  svge.currentScale = oldScale;
  svge.currentTranslate.x = oldTranslate.x;
  svge.currentTranslate.y = oldTranslate.y;
}

function adjustSVGzoom(svge, amount) {
  var newScale
  if (amount < 0){newScale=svge.currentScale/1.1}
  if (amount > 0){newScale=svge.currentScale*1.1}
  if (amount ==0){newScale=1}
  var oldScale=svge.currentScale
  var y = svge.clientHeight / 2;
  svge.currentTranslate.y=(-y+svge.currentTranslate.y)*(newScale/oldScale)
  svge.currentTranslate.x=(0+svge.currentTranslate.x)*(newScale/oldScale)
  svge.currentScale=newScale
  svge.currentTranslate.y+=y;
  svge.currentTranslate.x+=0;
}

function zoomSVG(amount) {
  const svge = svgResult.children[0];
  adjustSVGzoom(svge, amount);
  if (amount==0) {
    svge.currentTranslate.y = 0;
    svge.currentTranslate.x = 0;
  }
}

function addSVGZoomAndPan(svg){
  // From https://github.com/Holger-Will/SVGZoomAndPan/blob/master/zap.js
  svg.addEventListener("wheel",function(evt){
    var newScale
    if(evt.deltaY>0){newScale=svg.currentScale/1.1}
    if(evt.deltaY<0){newScale=svg.currentScale*1.1}
    var oldScale=svg.currentScale
     svg.currentTranslate.x=(-evt.offsetX+svg.currentTranslate.x)*(newScale/oldScale)
     svg.currentTranslate.y=(-evt.offsetY+svg.currentTranslate.y)*(newScale/oldScale)
     svg.currentScale=newScale
     svg.currentTranslate.x+=evt.offsetX
     svg.currentTranslate.y+=evt.offsetY
     var event = new Event('SVGZoom');
     svg.dispatchEvent(event);
     evt.preventDefault();  // Stop window from scrolling (update to zap.js)
  })
  svg.addEventListener("mousedown",function(evt){
    if(evt.shiftKey || evt.button==1){
      svg.classList.add("dragging")
      var ox=evt.offsetX
      var oy=evt.offsetY
      var otx=svg.currentTranslate.x
      var oty=svg.currentTranslate.y
      svg.addEventListener("mousemove",move)
      document.addEventListener("mouseup",out)
      var event = new Event('SVGScroll');
      svg.dispatchEvent(event)
      function out(evt){
        svg.removeEventListener("mousemove",move)
        document.removeEventListener("mouseup",out)
        svg.classList.remove("dragging")
        var event = new Event('SVGScroll');
        svg.dispatchEvent(event)
      }
      function move(evt){
        svg.currentTranslate.x=otx+(evt.offsetX-ox)
        svg.currentTranslate.y=oty+(evt.offsetY-oy)
        var event = new Event('SVGScroll');
        svg.dispatchEvent(event)
      }
    }
  })
}


function updateResult() {
  scaleLabel.innerText = scale.value;

  var svgPath = '';

  /*
  if (exclusion.checked) {
    svgPath += '<path d="M-250 -1800 l0 3000 l8000 0 l0 -3000 z" fill="#c0c0c0"/>'
  }
  */
  if (baseLine.checked) {
    svgPath +=
      '<path style="stroke:#ff4040;stroke-opacity:0.5;stroke-width:5" d="M-300 0 L16000 0"></path>'+
      '<path style="stroke:#ff4040;stroke-opacity:0.5;stroke-width:5" d="M0 -1500 L0 3000"></path>';
  }

  if (script.value !== '') {
    hbsvg2.options.script = script.value;
    hbsvg2.options.language = language.value;
    if (dirLTR.checked)
      hbsvg2.options.direction = 'ltr';
    else
      hbsvg2.options.direction = 'rtl';
  } else {
    hbsvg2.options.script = '';
    hbsvg2.options.language = '';
    hbsvg2.options.direction = '';
  }
  hbsvg2.options.featureString = features.value;
  hbsvg2.options.scale = scale.value;
  hbsvg2.options.x_stretch = parseInt(stretch.value, 10);
  hbsvg2.options.x = parseInt(offset2.value, 10);

  hbsvg2.options.colour_solid = solid2.value;// '#f37418';
  hbsvg2.options.colour_mode = 0;
  hbsvg2.options.opacity_fill = opacityFill2.value;
  hbsvg2.options.opacity_stroke = opacityStroke2.value;
  hbsvg2.options.stroke_width = strokeWidth2.value;
  hbsvg2.options.colour_mode = 0;
  if (colourGlyph2.checked) hbsvg2.options.colour_mode= 1;
  if (colourCluster2.checked) hbsvg2.options.colour_mode = 2;

  hbsvg1.copyOptions(hbsvg2.options);
  hbsvg1.options.x = 0;
  hbsvg1.options.colour_solid = solid1.value; //'#1685f3';
  hbsvg1.options.colour_mode = 0;
  /*
  if (exclusion.checked) {
    hbsvg1.options.blendMode = 'multiply';
  }
  */
  hbsvg1.options.showGids = showGids.checked;
  if (colourGlyph.checked) hbsvg1.options.colour_mode= 1;
  if (colourCluster.checked) hbsvg1.options.colour_mode = 2;

  hbsvg1.options.opacity_fill = opacityFill.value;
  hbsvg1.options.opacity_stroke = opacityStroke.value;
  hbsvg1.options.stroke_width = strokeWidth.value;

  if (hbsvg2.fontBlob) {
    svgPath += hbsvg2.toSvg(text.value, true, false);
    harfBuzzResult2.innerHTML = getHarfBuzzResult(hbsvg2);
    shapeResult2.innerHTML = getShapeResult(hbsvg2);
  } else {
    harfBuzzResult2.innerHTML = '';
    shapeResult2.innerHTML = '';
  }
  if (hbsvg1.fontBlob) {
    svgPath += hbsvg1.toSvg(text.value, true, true);
    harfBuzzResult1.innerHTML = getHarfBuzzResult(hbsvg1);
    shapeResult1.innerHTML = getShapeResult(hbsvg1);
  } else {
    harfBuzzResult1.innerHTML = '';
    shapeResult1.innerHTML = '';
  }
  fontName1.innerHTML = hbsvg1.fileDescription || '';
  fontName2.innerHTML = hbsvg2.fileDescription || '';


  // NOTE: Origin 0,0 is top left.
  var xmin = -250;    // Space to the LEFT
  var ymin = -1800;   // Space ABOVE
  var height = 3000;
  var heightOut = 400;
  var width = (window.innerWidth) * height / heightOut * 0.95;

  var bbox = xmin + ' ' + ymin + ' ' + width + ' ' + height;

  var ih = '<svg xmlns="http://www.w3.org/2000/svg"'
    +' height="'+heightOut+'"'
    +' viewBox="' + bbox + '"'
    +'>';
  if (textLineInfo) {
    ih += '<text font-size="120" x="0" y="1200" fill="green">'+textLineInfo+'</text>';
  }
  ih += svgPath + '</svg>';
  updateSvg(svgResult, ih);
  var svge = svgResult.children[0];
  addSVGZoomAndPan(svge);
  //debugResult.innerText = 'upem='+hbsvg1.face.upem;
}

function onResourcesLoaded() {
  var fontname = 'samples/Gulzar-Regular-1.002.ttf';
  fetch(fontname).then(function (res) {
    return res.arrayBuffer();
  }).then(function (blob) { // can be used without our wrapper
    window.fontBlob = new Uint8Array(blob);
    hbsvg1.setFontBlob(window.fontBlob);
    hbsvg2.freeFontBlob();
    acquireFontAndLists(window.opener);
    updateResult();
    updateLists();
  });
}

let harfBuzzModule; // not really needed with the hbjs wrapper
createHarfBuzz().then(hbmodule=>{
  harfBuzzModule = hbmodule;
  window.hb = hbjs(hbmodule);
  hbversion.innerHTML=hb.version_string()
  onResourcesLoaded();
});

function UpdateListener(id, event, foo) {
  var e = document.getElementById(id);
  if (e && !foo) {
    e.addEventListener(event, function(e) {
      updateResult();
      updateLists();
    });
  } else
  if (e) {
    e.addEventListener(event, function(e) {
      foo(e);
    });
  }
}

/*
document.addEventListener('dragover', function (e) {
  e.stopPropagation(); e.preventDefault();
}, false);
document.addEventListener('dragleave', function (e) {
  e.stopPropagation(); e.preventDefault();
}, false);
document.addEventListener('drop', function (e) {
  e.stopPropagation(); e.preventDefault();
  //ef.value = e.dataTransfer.files[0];
  handleFontUpdate(e.dataTransfer.files[0]);
});
*/


function handleFontUpdate(file, which) {
  if (!file) return;
  var reader = new FileReader();
  reader.addEventListener("load", function () {
    window.fontBlob = new Uint8Array(reader.result);
    if (!which) {
      if (fontOne.checked)
        hbsvg1.setFontBlob(window.fontBlob);
      else
        hbsvg2.setFontBlob(window.fontBlob);
    } else {
      which.setFontBlob(window.fontBlob);
    }
    updateResult();
    updateLists();
  });
  var fdate = new Date(file.lastModified);
  reader.readAsArrayBuffer(file);
}

function handleTextDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  console.log(fileName);
  textLineFileName = fileName;
  if (!fileName.endsWith('.txt')) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    updateTextLines(reader.result);
    hideTextButtons(false);
    gotoLineFirst();
  }
  reader.readAsText(file);
}

function handleFontUpdate1(file) { handleFontUpdate(file, hbsvg1); }
function handleFontUpdate2(file) { handleFontUpdate(file, hbsvg2); }

patchDragDrop(document.getElementById('dropOne'), handleFontUpdate1);
patchDragDrop(document.getElementById('dropName1'), handleFontUpdate1);
patchDragDrop(document.getElementById('dropTwo'), handleFontUpdate2);
patchDragDrop(document.getElementById('dropName2'), handleFontUpdate2);
patchDragDrop(document.getElementById('textdrop'), handleTextDrop);

// Operate on results of font.pathToJson(gid)
// extxy - gets filled with the maximum extents .x and .y of the glyph
//         so can be used for advance in the GSUB stage (where there's no metrics yet available)
function glyphToRelative(glyph, retxy, extxy) {
  var r = [];
  var x = 0;
  var y = 0;
  var last_x, last_y;
  var ext = {xl:null, yl:null, xh:null, yh:null};
  var res = glyph.reduce( (acc,w) => {
    var v = {};
    v.type = w.type.toLowerCase();
    v.values = w.values.map( function(z, i) {
      if (i%2)
      {
        last_y = z;
        return -(z - y);
      } else
      {
        last_x = z;
        return z - x;
      }
      });
    x = last_x;
    y = last_y;
    if ((ext.xh === null) || (x>ext.xh)) ext.xh = x;
    if ((ext.yh === null) || (y>ext.yh)) ext.yh = y;
    if ((ext.xl === null) || (x<ext.xl)) ext.xl = x;
    if ((ext.yl === null) || (y<ext.yl)) ext.yl = y;
    return acc.concat(v);
  }, []);
  // Go back to relative origin...
  if (retxy) {
    var v = {}
    v.type = 'm';
    v.values = [-x, y];
    res.push(v);
  }
  if (extxy) {
    extxy.xh = ext.xh;
    extxy.yh = ext.yh;
    extxy.xl = ext.xl;
    extxy.yl = ext.yl;
    if (extxy.xh === null) extxy.xh = 0;
    if (extxy.yh === null) extxy.yh = 0;
    if (extxy.xl === null) extxy.xl = 0;
    if (extxy.yl === null) extxy.yl = 0;
    extxy.w = (ext.xh - ext.xl)
    extxy.h = (ext.yh - ext.yl)
  }
  return res;
}

function jsonToSvg(pathArray) {
  var res = pathArray.reduce( (acc, gl) => {
    var v = gl.type + gl.values.join(' ');
    return acc.concat(v);
  }, '');
  return res;
}

function generateHtmlForTrace(trace, index) {
  var i = index;
  var html = '';
  if (typeof trace === 'undefined') return html;
  const message = trace[index].m;
  if (index >= trace.gpos_point) html += 'GPOS ';
  else if (index >= trace.gsub_point) html += 'GSUB ';
  html += '#'+i+': ';
  html += message;
  return html;
}

function generateBuffer(text, options) {
  var buffer = hb.createBuffer();
  buffer.addText(text);
  buffer.guessSegmentProperties();
  if (options.direction && options.direction.length > 0) {
    buffer.setDirection(options.direction || 'ltr');
  }
  if (options.script && options.script.length > 0) {
    buffer.setScript(options.script || 'latn');
  }
  if (options.language && options.language.length > 0) {
    buffer.setLanguage(options.language);
  }
  return buffer;
}

function transferResult(result, trace_entry, hb_entry) {
  var re = {};
  re.g = trace_entry.g;
  re.cl = trace_entry.cl;
  if (typeof trace_entry.ax === 'undefined') {
    re.ax = NaN; // This is picked up later and we use the glyphs max.x to advance
    re.ay = 0;
    re.dx = 0;
    re.dy = 0;
    re.flags = 0;
  } else {
    re.ax = trace_entry.ax;
    re.ay = trace_entry.ay;
    re.dx = trace_entry.dx;
    re.dy = trace_entry.dy;
    re.flags = trace_entry.flags;
  }
  re.H = trace_entry.H
  result.push(re);
}

function createResultArrayFromTrace(font, trace, hb_result) {
  // NOTE: hb_result[0].cl shows us which direction we should generate
  //       compared to the trace.cl
  // NOTE: in the case of a GSUB sequence, we can take the ax,ay,dx,dy from the hb_result
  //       to show meaningful info (that HarfBuzz has slightly cooked)
  var result = [];
  const tr = trace[trace.length - 1];
  const t = tr.t;
  if (typeof t === 'undefined') return result;

  // Scan for ' at ...' in the tr.m field
  var sets = tr.m.match(/ at [\d,]+/g);
  if (sets !== null) {
    var i = 0;
    while (i < sets.length) {
      const indices = sets[i].match(/\d+/g);
      var j = 0;
      while (j < indices.length) {
        const n = parseInt(indices[j], 10);
        t[n].H = i+1;
        j++;
      }
      i++;
    }
  }

  if (hb_result[0].cl == t[0].cl) {
    // Same direction
    var i = 0;
    while (i < t.length) {
      const te = t[i];
      if (typeof te === 'undefined') break;
      transferResult(result, te, hb_result[i]);
      i++;
    }
  } else {
    // Need to reverse
    var i = t.length - 1;
    var hi = 0;
    while (i >= 0) {
      const te = t[i];
      transferResult(result, te, hb_result[hi]);
      hi++;
      i--;
    }
  }
  return result;
}

function hbToSvg(obj, text, options, doTimeline, doUpdateScrubInfo)
{
  obj = obj || {};
  if (!("blob" in obj)) obj.blob = hb.createBlob(obj.fontBlob);
  if (!("face" in obj)) obj.face = hb.createFace(obj.blob, 0);
  if (!("font" in obj)) obj.font = hb.createFont(obj.face);
  var font = obj.font;
  const primary = doUpdateScrubInfo; //(obj == hbsvg1);
  if ("scale" in options)
    font.setScale(options.scale, options.scale); // Optional, if not given will be in font upem

  var buffer = generateBuffer(text, options);
  var featureString = '';
  if (options.featureString && options.featureString.length > 0) {
    var featureString = `+DUMY,${options.featureString},`; // Copied from Crowbar... "SERIOUSLY?"
  }
  const limits = {maxGlyphRatio:100.0, maxDepth:100};

  obj.trace = hb.shapeWithTraceLimits(font, buffer, featureString, null, null, limits, null);

  var result;
  if (doTimeline) {
    var stop_count = null;
    scrubber_count.innerText = obj.trace.count;
    if (scrubber.value > 0) stop_count = scrubber.value;
    var buffer_trace = generateBuffer(text, options);
    obj.trace_part = hb.shapeWithTraceLimits(font, buffer_trace, featureString, null, null, limits, stop_count);
    if (stop_count > 0)
      result = createResultArrayFromTrace(font, obj.trace_part, buffer_trace.json(font));
    else
      result = buffer_trace.json(font);

    buffer_trace.destroy();
    if (primary) {
      if (!stop_count) {
        // Update the scrubber limits as we have a 'full' shaping count info
        scrubber.max = obj.trace.count;
        scrubber_text.innerText =
          ' GSUB:'+obj.trace.gsub_point +
          ' GPOS:'+obj.trace.gpos_point +
          ' Total:'+obj.trace.count;
      } else {
        var idx = stop_count - 1; //obj.trace.length - 1;
        scrubber_text.innerHTML = generateHtmlForTrace(obj.trace, idx);
      }
    }
  } else {
    result = buffer.json(font);
  }

  // returns glyphs paths, totally optional
  var glyphs = {};
  //var paths  = {};
  result.forEach(function (x) {
    if (glyphs[x.g]) return;
    glyphs[x.g] = font.glyphToJson(x.g);
    //paths[x.g]  = font.glyphToPath(x.g);
  });
  buffer.destroy();

  var opacf = options.opacity_fill; // || 0.7
  var opacs = options.opacity_stroke;// || 0.3;
  var stroke_width = options.stroke_width || 11;
  var x_stretch = options.x_stretch || 0;
  var svgPath = '';
  var x = options.x || 0;
  var y = options.y || 0;
  var colour_i = 0;
  var cluster_n = -1;
  var colour_mode = options.colour_mode || 0;
  var colour_solid = options.colour_solid || '#f37418'; // #0523d4 (blue)
  var r;
  var idx = 0;
  var n = 0;

  for (r of result) {
    var colourGlyph = colour_solid;
    var colourStroke = colour_solid;
    var colourText = colour_solid;
    var colourExtents = colour_solid;
    if (!colour_mode == 0)
    {
      if (colour_mode == 1) {
        colour_i++;
      } else
      if (colour_mode == 2) {
        if (cluster_n != r.cl) {
          colour_i++;
        }
      }
      cluster_n = r.cl;
      colourGlyph   = glyphColors[colour_i%glyphColors.length];
      colourStroke  = colour_solid;
      colourText    = colourGlyph;
      colourExtents = colourGlyph;
    } else {
      colour_i++;
      colourStroke  = glyphColors[colour_i%glyphColors.length];
      colourText    = colourStroke;
      colourExtents = colourStroke;
    }
    var blendMode = options.blendMode || 'normal';
    var ext = {};
    const glyphSvg = jsonToSvg(glyphToRelative(glyphs[r.g], false, ext));
    if (isNaN(r.ax)) {
      // for GSUB phase where there's no advance
      // (r.ax will be set to -1 in `transferResult`)
      if (ext.w <= 1) ext.w = (obj.face.upem / 6);
      if (ext.xl < 0) r.dx = -ext.xl
      if (ext.xh > ext.w) r.ax = ext.xh; else r.ax = ext.w;
    }
    var path = '';
    if (showBoundingBox.checked && primary) {
      path += '<rect style="fill:'+colourExtents
           +';fill-opacity:0.15;mix-blend-mode:\'multiply\'" '
           +'width="'+(ext.w)+'"'
           +'height="'+(ext.h)+'"'
           +'x="'+(x+r.dx+ext.xl)+'" y="'+(y-r.dy-ext.yh)+'"'
           +'/>'
    }
    if (r.H) {
      var highlight_fill, highlight_stroke;
      if (r.H == 1) {
        highlight_fill   = '#ffff00';
        highlight_stroke = '#ff0000';
      }
      else {
        highlight_fill   = '#ffff00';
        highlight_stroke = '#80c000';
      }
      path += '<rect style="fill:'+highlight_fill+';fill-opacity:0.6;mix-blend-mode:normal;'
              +'stroke-opacity:0.5;stroke-width:20;stroke:'+highlight_stroke+'"'
           +'width="'+(ext.w)+'"'
           +'height="'+(ext.h)+'"'
           +'x="'+(x+r.dx+ext.xl)+'" y="'+(y-r.dy-ext.yh)+'"'
           +'/>'
    }
    if (showOrigin.checked && primary) {
      path += '<circle r="'+(20* options.scale / 1000)+'"'
           +'style="fill-opacity:0.5;" '
           +'cx="'+(x+r.dx)+'" '
           +'cy="'+(y-r.dy)+'" '
           +'fill="'+colourExtents+'" />'
    }
    path +=
        '<path '+
          'id="n'+n+'_g'+r.g+'_c'+r.cl+'"'+
          'style="fill:'
          +colourGlyph
          +';stroke:'+colourStroke
          //+';paint-order:stroke'+
          +';fill-opacity:'+opacf+';stroke-opacity:'+opacs+';stroke-width:'+stroke_width
          +'; mix-blend-mode:\''+blendMode+'\'" '
        +'d="M'+x+' '+y+' '         // The absolute origin
        +'m'+r.dx+' '+(-r.dy)+' '   // negative y because the SVG coordinates are upside down
        +glyphSvg
        +'"/>\r\n';
    if (options.showGids) {
      var xOfs = 0; //r.dx
      var fontSize = 100 * options.scale / 1000;
      var yOfs = -650 - (idx % 4) * 130;
      yOfs = yOfs * options.scale / 1000;
      path += '<text font-size="'+fontSize+'" x="'+(x+xOfs)+'" y="'+(y-yOfs)+'" fill="'+colourText+'">'+r.g+'</text>';
      idx++;
    }
    svgPath += path;
    x += r.ax + x_stretch;
    y += r.ay;
    n++;
  }
  obj.results.x_end = x;
  obj.results.y_end = y;
  obj.results.svgPath = svgPath;
  obj.results.json = result; // the JSON result
  return svgPath;
}

function textToUnicode(str) {
  return str.split('').map(function (value, index, array) {
    var temp = value.charCodeAt(0).toString(16); //.toUpperCase();
    return temp;
  }).join(' ');
}

function unicodeToText(uni, maxLength) {
  var txt = uni.split(' ').map(function(value, index, array) {
    if (value.length == 0) return '';
    return String.fromCharCode('0x'+value);
  }).join('');
  if (maxLength) txt = txt.slice(0, maxLength); // Keep only 100 characters
  return txt;
}

function resetScrubber() {
  scrubber.value = 0;
}

function UpdateUnicode(e) {
  text.value = unicodeToText(unicode.value, 100);
  resetScrubber();
  updateResult();
}

function UpdateText(e) {
  resetScrubber();
  text.value = text.value.slice(0, 100); // throw away silly amounts of text. Keep only 100 characters
  unicode.value = textToUnicode(text.value);
  updateResult();
}

function UpdateScrubber(e) {
  updateResult();
}

function UpdateWithTimeline(e) {
  updateResult();
  updateLists();
  resetScrubber();
}

function acquireFontAndLists() {
  if (!window.opener) return;
  const w = window.opener;
  if (!isExists(w.api) || !isExists(w.api.transfer)) return;
  const xfer = w.api.transfer;  // Use this as a conduit for values to be passed in here
  updateTransfer(xfer);
}

function updateTransfer(xfer) {
  // Get values from the other tool...
  if (!xfer) return;
  if (isExists(xfer.fontBlob1)) hbsvg1.setFontBlob(xfer.fontBlob1);
  if (isExists(xfer.fontBlob2)) hbsvg2.setFontBlob(xfer.fontBlob2);
  if (isExists(xfer.checkList) && (xfer.checkList.length > 0)) {
    mya = [];
    var i = 0;
    while (i < xfer.checkList.length) {
      mya.push(xfer.checkList[i]);
      i++;
    }
    hideTextButtons(false);
  }
  if (xfer.script !== null)   script.value   = xfer.script;
  if (xfer.language !== null) language.value = xfer.language;
  gotoLineFirst();
}

// Glue update events...
UpdateListener('text', 'keyup', UpdateText);
UpdateListener('unicode', 'keyup', UpdateUnicode);
UpdateListener('script', 'keyup', UpdateWithTimeline);
UpdateListener('language', 'keyup', UpdateWithTimeline);
UpdateListener('dirLTR', 'input', UpdateWithTimeline);
UpdateListener('dirRTL', 'input', UpdateWithTimeline);
UpdateListener('stretch', 'input');
UpdateListener('offset2', 'input');
UpdateListener('opacityFill', 'input');
UpdateListener('opacityStroke', 'input');
UpdateListener('strokeWidth', 'input');
UpdateListener('opacityFill2', 'input');
UpdateListener('opacityStroke2', 'input');
UpdateListener('strokeWidth2', 'input');
UpdateListener('colourGlyph', 'input');
UpdateListener('colourCluster', 'input');
UpdateListener('colourSolid', 'input');
UpdateListener('solid1', 'input');
UpdateListener('colourGlyph2', 'input');
UpdateListener('colourCluster2', 'input');
UpdateListener('colourSolid2', 'input');
UpdateListener('solid2', 'input');
UpdateListener('scale', 'input');
UpdateListener('showGids', 'input');
UpdateListener('features', 'input', UpdateWithTimeline);
UpdateListener('baseLine', 'input');
UpdateListener('showBoundingBox', 'input');
UpdateListener('showOrigin', 'input');
UpdateListener('exclusion', 'input');
UpdateListener('scrubber', 'input', UpdateScrubber);
resetScrubber();

</script>

<p>Also useful: <a href="https://www.corvelsoftware.co.uk/crowbar/" target="_blank">Crowbar Font Tester (Simon Cozens)</a>
<p>Based on <a href="https://github.com/harfbuzz/harfbuzzjs" target="_blank">harfbuzzjs</a> demo. Supports font drag and drop.</p>
<p><a href="https://github.com/MattMatic/hbfontcompare" target="_blank">https://github.com/MattMatic/hbfontcompare</a>
</br>HarfBuzz Version: <span id="hbversion"></span>
</br>Tool Version: 2025-06-26
</p>
</html>
